;;-*-Lisp-*-
(in-package goal)



(deftype lavabase (process-drawable)
  ()
  :heap-base #x40
  :method-count-assert 20
  :size-assert         #xb0
  :flag-assert         #x14004000b0
  (:states
    lavabase-idle
    )
  )


(defskelgroup *lavabase-sg* lavabase lavabase-lod0-jg lavabase-idle-ja
              ((lavabase-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 22)
              :longest-edge (meters 9.4)
              )

(defstate lavabase-idle (lavabase)
  :code (behavior ()
    (loop
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior lavabase) ja-post)
  )

(defmethod init-from-entity! lavabase ((obj lavabase) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *lavabase-sg* '())
  (go lavabase-idle)
  (none)
  )

(deftype lavafall (process-drawable)
  ()
  :heap-base #x40
  :method-count-assert 20
  :size-assert         #xb0
  :flag-assert         #x14004000b0
  (:states
    lavafall-idle
    )
  )


(defskelgroup *lavafall-sg* lavafall lavafall-lod0-jg lavafall-idle-ja
              ((lavafall-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 50 0 53)
              :longest-edge (meters 5.4)
              )

(defstate lavafall-idle (lavafall)
  :code (behavior ()
    (loop
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior lavafall) ja-post)
  )

(defmethod init-from-entity! lavafall ((obj lavafall) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *lavafall-sg* '())
  (go lavafall-idle)
  (none)
  )


(deftype cyclegen (structure) ;; cyclegen needed for the hutlamp
  ((output float  :offset-assert   0)
   (inc    float  :offset-assert   4)
   )
  :pack-me
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )


(defun set-period ((arg0 cyclegen) (arg1 int))
  (set! (-> arg0 inc) (/ 5.0 (the float arg1)))
  )

(defun update-clock ((arg0 cyclegen))
  (let ((f0-1 (+ (-> arg0 output) (* (-> arg0 inc) (-> *display* time-adjust-ratio)))))
    (set! (-> arg0 output) (- f0-1 (the float (the int f0-1))))
    )
  (-> arg0 output)
  )

(deftype hutlamp (process-drawable)
  ((pivot joint-mod-set-local         :offset-assert 176)
   (clock cyclegen            :inline :offset-assert 180)
   )
  :heap-base #x50
  :method-count-assert 20
  :size-assert         #xbc
  :flag-assert         #x14005000bc
  (:states
    hutlamp-idle
    )
  )


(defmethod relocate hutlamp ((obj hutlamp) (arg0 int))
  (if (nonzero? (-> obj pivot))
      (&+! (-> obj pivot) arg0)
      )
  (the-as
    hutlamp
    ((the-as (function process-drawable int process-drawable) (find-parent-method hutlamp 7)) obj arg0)
    )
  )

(defskelgroup *hutlamp-sg* hutlamp hutlamp-lod0-jg hutlamp-idle-ja
              ((hutlamp-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1 0 1.2)
              :longest-edge (meters 0.7)
              )

(defstate hutlamp-idle (hutlamp)
  :code (behavior ()
    (loop
      (let ((f0-3 (* 1820.4445 (sin (* 65536.0 (update-clock (-> self clock)))))))
        (quaternion-vector-angle! (-> self pivot transform quat) *x-vector* f0-3)
        )
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior hutlamp) ja-post)
  )

(defmethod init-from-entity! hutlamp ((obj hutlamp) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *hutlamp-sg* '())
  (set! (-> obj pivot) (new 'process 'joint-mod-set-local obj 3 #f #t #f))
  (set-period (-> obj clock) 900)
  (set! (-> obj clock output) (rand-vu))
  (go hutlamp-idle)
  (none)
  )

(deftype pusher-base (process-drawable)
  ((root-override collide-shape-moving  :offset        112)
   (max-frame     float                 :offset-assert 176)
   )
  :heap-base #x50
  :method-count-assert 20
  :size-assert         #xb4
  :flag-assert         #x14005000b4
  )


(deftype pusher (pusher-base)
  ((sync sync-info-paused :inline :offset-assert 180)
   (cyl  cylinder         :inline :offset-assert 208)
   )
  :heap-base #x90
  :method-count-assert 20
  :size-assert         #xf8
  :flag-assert         #x14009000f8
  (:states
    pusher-idle
    )
  )

(defskelgroup *pusher-sg* pusher pusher-lod0-jg pusher-idle-ja
              ((pusher-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              )

(defbehavior pusher-base-init pusher-base ()
  (logior! (-> self mask) (process-mask enemy platform))
  (let ((gp-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-others))))
    (set! (-> gp-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> gp-0 reaction) default-collision-reaction)
    (set! (-> gp-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s5-0 (new 'process 'collide-shape-prim-group gp-0 (the-as uint 1) 0)))
      (set! (-> s5-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s5-0 collide-with) (collide-kind target))
      (set! (-> s5-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s5-0 transform-index) 0)
      (set-vector! (-> s5-0 local-sphere) -8192.0 0.0 0.0 40960.0)
      (set-root-prim! gp-0 s5-0)
      (let ((s4-0 (new 'process 'collide-shape-prim-mesh gp-0 (the-as uint 0) (the-as uint 0))))
        (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s4-0 collide-with) (collide-kind target))
        (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
        (set! (-> s4-0 transform-index) 4)
        (set-vector! (-> s4-0 local-sphere) 8192.0 0.0 0.0 28672.0)
        (append-prim s5-0 s4-0)
        )
      )
    (set! (-> gp-0 nav-radius) (* 0.75 (-> gp-0 root-prim local-sphere w)))
    (backup-collide-with-as gp-0)
    (set! (-> self root-override) gp-0)
    gp-0
    )
  )

(defstate pusher-idle (pusher)
  :trans (the-as (function none :behavior pusher) rider-trans)
  :code (behavior ()
    (loop
      (let ((f0-0 -1.0))
        (when (and *target* *camera*)
          (let ((gp-0 (new 'stack-no-clear 'vector)))
            (vector-! gp-0 (target-pos 0) (camera-pos))
            (set! f0-0 (ray-capsule-intersect (-> self cyl) (camera-pos) gp-0))
            )
          )
        (if (< f0-0 0.0)
            (ja :num! (seek! (get-current-value-with-mirror (-> self sync) (-> self max-frame))))
            (ja :num! (seek! 0.0))
            )
        )
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior pusher) rider-post)
  )

(defmethod init-from-entity! pusher ((obj pusher) (arg0 entity-actor))
  (pusher-base-init)
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *pusher-sg* '())
  (load-params! (-> obj sync) obj (the-as uint 1500) 0.0 0.15 0.15)
  (set! (-> obj max-frame) (res-lump-float arg0 'max-frame :default (the float (ja-num-frames 0))))
  (set! (-> obj cyl origin quad) (-> obj root-override trans quad))
  (vector-x-quaternion! (-> obj cyl axis) (-> obj root-override quat))
  (vector-negate! (-> obj cyl axis) (-> obj cyl axis))
  (set! (-> obj cyl length) 36864.0)
  (set! (-> obj cyl radius) 20480.0)
  (go pusher-idle)
  (none)
  )

(deftype villagec-lava (water-anim)
  ()
  :heap-base #x70
  :method-count-assert 30
  :size-assert         #xdc
  :flag-assert         #x1e007000dc
  )


(define ripple-for-villagec-lava (new 'static 'ripple-wave-set
                                   :count 2
                                   :converted #f
                                   :wave (new 'static 'inline-array ripple-wave 4
                                     (new 'static 'ripple-wave :scale 40.0 :xdiv 2 :speed 1.5)
                                     (new 'static 'ripple-wave :scale 40.0 :xdiv -2 :zdiv 2 :speed 0.9)
                                     (new 'static 'ripple-wave)
                                     (new 'static 'ripple-wave)
                                     )
                                   )
        )

(defmethod water-vol-method-22 villagec-lava ((obj villagec-lava))
  (let ((t9-0 (method-of-type water-anim water-vol-method-22)))
    (t9-0 obj)
    )
  (let ((v1-2 (new 'process 'ripple-control)))
    (set! (-> obj draw ripple) v1-2)
    (set! (-> v1-2 global-scale) 3072.0)
    (set! (-> v1-2 waveform) ripple-for-villagec-lava)
    )
  (logclear! (-> obj flags) (water-flags wt23))
  (logior! (-> obj flags) (water-flags wt25))
  (set! (-> obj attack-event) 'lava)
  (none)
  )

(deftype chainmine (process-drawable)
  ((root-override collide-shape-moving  :offset 112)
   )
  :heap-base #x40
  :method-count-assert 22
  :size-assert         #xb0
  :flag-assert         #x16004000b0
  (:methods
    (die () _type_ :state 20)
    (idle () _type_ :state 21)
    )
  )


(defpartgroup group-chainmine-explode
  :id 542
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 2132 :period (seconds 2) :length (seconds 0.017))
    (sp-item 2133 :period (seconds 2) :length (seconds 0.135))
    (sp-item 2134 :period (seconds 2) :length (seconds 0.067))
    (sp-item 2135 :period (seconds 2) :length (seconds 0.067))
    )
  )

(defpart 2133
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 8.0)
    (:y (meters 0))
    (:scale-x (meters 0.4) (meters 0.8))
    (:scale-y :copy scale-x)
    (:r 192.0 64.0)
    (:g 192.0 64.0)
    (:b 128.0)
    (:a 32.0 96.0)
    (:vel-y (meters 0.053333335) (meters 0.21333334))
    (:scalevel-x (meters -0.0026666666))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -2.1333334)
    (:fade-b -1.4222223)
    (:accel-y (meters -0.00016666666) (meters -0.00016666666))
    (:friction 0.9)
    (:timer (seconds 1))
    (:flags (bit2 bit14))
    (:next-time (seconds 0.1) (seconds 0.297))
    (:next-launcher 2136)
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2) (meters 4))
    )
  )

(defpart 2136
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:fade-a -1.0666667))
  )

(defpart 2135
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 6.0)
    (:y (meters 0))
    (:scale-x (meters 0.4))
    (:rot-z (degrees 0) (degrees 180))
    (:scale-y (meters 16))
    (:r 255.0)
    (:g 196.0)
    (:b 64.0)
    (:a 32.0 64.0)
    (:scalevel-y (meters 1.04))
    (:fade-g -3.2666667)
    (:fade-b -1.0666667)
    (:fade-a -1.6)
    (:timer (seconds 0.2))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 2132
  :init-specs ((:texture (new 'static 'texture-id :index #x12 :page #x2))
    (:num 1.0)
    (:y (meters 0))
    (:scale-x (meters 32))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 192.0 32.0)
    (:b 128.0)
    (:a 128.0)
    (:fade-a -2.3272727)
    (:timer (seconds 0.18))
    (:flags (bit2 bit3 bit14))
    )
  )

(defpart 2134
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 16.0)
    (:scale-x (meters 4) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 128.0 64.0)
    (:b 128.0)
    (:a 64.0 64.0)
    (:vel-y (meters 0.08) (meters 0.04))
    (:scalevel-x (meters 0.02))
    (:rotvel-z (degrees -0.6) (degrees 1.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.28444445)
    (:accel-y (meters 0.00016666666) (meters 0.00016666666))
    (:friction 0.8)
    (:timer (seconds 1.7))
    (:flags (bit2 bit14))
    (:next-time (seconds 0.14))
    (:next-launcher 2137)
    (:conerot-x (degrees 0) (degrees 180))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0) (meters 2))
    )
  )

(defpart 2137
  :init-specs ((:fade-r -1.0666667)
    (:fade-g -1.0666667)
    (:fade-b -2.1166666)
    (:next-time (seconds 0.2))
    (:next-launcher 2138)
    )
  )

(defpart 2138
  :init-specs ((:fade-r -0.5688889)
    (:fade-g -0.28444445)
    (:fade-b 0.0)
    (:fade-a -0.21333334)
    (:next-time (seconds 0.75))
    (:next-launcher 2139)
    )
  )

(defpart 2139
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0))
  )

(defskelgroup *chainmine-sg* chainmine chainmine-lod0-jg chainmine-idle-ja
              ((chainmine-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -10.75 0 12.75)
              :longest-edge (meters 2.4)
              )

(defstate die (chainmine)
  :virtual #t
  :code (behavior ()
    (ja-channel-set! 0)
    (clear-collide-with-as (-> self root-override))
    (ja-post)
    (sound-play "dcrate-break")
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (set! (-> gp-1 quad) (-> self root-override trans quad))
      (+! (-> gp-1 y) -73728.0)
      (process-spawn
        part-tracker
        :init part-tracker-init
        (-> *part-group-id-table* 542)
        600
        #f
        #f
        #f
        gp-1
        :to *entity-pool*
        )
      )
    (suspend)
    (set! (-> self state-time) (-> *display* base-frame-counter))
    (until (>= (- (-> *display* base-frame-counter) (-> self state-time)) (seconds 1))
      (suspend)
      )
    (cleanup-for-death self)
    (deactivate self)
    (none)
    )
  )

(defstate idle (chainmine)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('attack 'touch)
       (send-event proc 'attack (-> event param 0) (static-attack-info ((mode 'deadly))))
       (go-virtual die)
       )
      )
    )
  :code (behavior ()
    (loop
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (if (nonzero? (-> self sound))
            (update! (-> self sound))
            )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior chainmine) ja-post)
  )

(defmethod init-from-entity! chainmine ((obj chainmine) (arg0 entity-actor))
  (logior! (-> obj mask) (process-mask attackable))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 -73728.0 0.0 18432.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *chainmine-sg* '())
  (set! (-> obj sound)
        (new 'process 'ambient-sound (static-sound-spec "lava-mine-chain" :fo-max 30) (-> obj root-override trans))
        )
  (go (method-of-object obj idle))
  (none)
  )

(deftype bladeassm (process-drawable)
  ((root-override collide-shape-moving  :offset        112)
   (angle         float                 :offset-assert 176)
   )
  :heap-base #x50
  :method-count-assert 20
  :size-assert         #xb4
  :flag-assert         #x14005000b4
  (:states
    bladeassm-idle
    )
  )


(defskelgroup *bladeassm-sg* bladeassm bladeassm-lod0-jg bladeassm-idle-ja
              ((bladeassm-lod0-mg (meters 20)) (bladeassm-lod1-mg (meters 40)) (bladeassm-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 16)
              :longest-edge (meters 10)
              )

(defstate bladeassm-idle (bladeassm)
  :code (behavior ()
    (loop
      (+! (-> self angle) (* 3640.889 (-> *display* seconds-per-frame)))
      (set! (-> self angle) (the float (sar (shl (the int (-> self angle)) 48) 48)))
      (pusher-post)
      (suspend)
      )
    (none)
    )
  )

(defun bladeassm-prebind-function ((arg0 process-drawable) (arg1 int) (arg2 bladeassm) (arg3 event-message-block))
  (let ((v1-0 arg2))
    (quaternion-axis-angle! (the-as quaternion (&-> arg0 link)) 0.0 0.0 1.0 (-> v1-0 angle))
    )
  (the-as object 0)
  )

(defmethod init-from-entity! bladeassm ((obj bladeassm) (arg0 entity-actor))
  (logior! (-> obj mask) (process-mask ambient))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 49152.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *bladeassm-sg* '())
  (set! (-> obj skel prebind-function)
        (the-as (function pointer int process-drawable none) bladeassm-prebind-function)
        )
  (logclear! (-> obj mask) (process-mask actor-pause))
  (go bladeassm-idle)
  (none)
  )

(deftype caveflamepots (process-drawable)
  ((root-override      collide-shape           :offset        112)
   (shove-up           float                   :offset-assert 176)
   (cycle-speed        int32                   :offset-assert 180)
   (cycle-pause        int32                   :offset-assert 184)
   (cycle-offset       uint32                  :offset-assert 188)
   (was-deadly?        symbol                  :offset-assert 192)
   (should-play-sound? symbol                  :offset-assert 196)
   (launch-pos         vector        2 :inline :offset-assert 208)
   )
  :heap-base #x80
  :method-count-assert 20
  :size-assert         #xf0
  :flag-assert         #x14008000f0
  (:states
    caveflamepots-active
    )
  )


(defpart 704
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 1.0)
    (:x (meters -1.2) (meters 2.4))
    (:z (meters -1.2) (meters 2.4))
    (:scale-x (meters 4))
    (:rot-z (degrees -180) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 0.0)
    (:a 128.0)
    (:vel-y (meters 0.06) (meters 0.015))
    (:scalevel-x (meters -0.0039999997))
    (:rotvel-z (degrees -1.8) (degrees 1.8))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -0.8)
    (:fade-a -0.55333335)
    (:accel-y (meters -0.0006))
    (:timer (seconds 16.68))
    (:flags (bit2 bit3))
    )
  )


(defstate caveflamepots-active (caveflamepots)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch 'attack)
       (when (= (-> proc type) target)
         (when ((method-of-type touching-shapes-entry prims-touching-action?)
                (the-as touching-shapes-entry (-> event param 0))
                (-> *target* control)
                (collide-action solid)
                (collide-action)
                )
           (let ((s4-0 (new 'stack 'attack-info)))
             (calc-shove-up (-> self root-override) s4-0 (-> self shove-up))
             (if (or (= (-> *target* control unknown-surface00 mode) 'air)
                     (>= (+ (-> *display* base-frame-counter) (seconds -0.2)) (-> *target* control unknown-dword11))
                     (< 0.75 (-> *target* control poly-normal y))
                     )
                 (send-event
                   proc
                   'attack-or-shove
                   (-> event param 0)
                   (static-attack-info ((mode 'burn) (vector (-> s4-0 vector)) (shove-up (-> s4-0 shove-up))))
                   )
                 (send-event
                   proc
                   'attack-or-shove
                   (-> event param 0)
                   (static-attack-info ((mode 'burn)
                                        (shove-up (meters 0))
                                        (shove-back (meters 2))
                                        (vector (-> *target* control poly-normal))
                                        (angle 'shove)
                                        )
                                       )
                   )
                 )
             )
           )
         )
       )
      )
    )
  :trans (behavior ()
    (let* ((v1-0 (-> self cycle-speed))
           (a0-1 (- v1-0 (-> self cycle-pause)))
           (gp-0 (mod (+ (-> *display* base-frame-counter) (the-as time-frame (-> self cycle-offset))) v1-0))
           )
      (cond
        ((< gp-0 a0-1)
         (when (sphere-in-view-frustum? (the-as sphere (-> self root-override root-prim prim-core)))
           (launch-particles (-> *part-id-table* 704) (the-as vector (-> self launch-pos)))
           )
         (when (-> self should-play-sound?)
           (set! (-> self should-play-sound?) #f)
           (sound-play "hot-flame")
           )
         (cond
           ((< gp-0 30)
            (when (-> self was-deadly?)
              (set! (-> self was-deadly?) #f)
              (clear-collide-with-as (-> self root-override))
              )
            )
           (else
             (when (not (-> self was-deadly?))
               (set! (-> self was-deadly?) #t)
               (restore-collide-with-as (-> self root-override))
               )
             )
           )
         (when (and (not (-> self was-deadly?)) (< 60 gp-0))
           (set! (-> self was-deadly?) #t)
           (restore-collide-with-as (-> self root-override))
           )
         )
        (else
          (set! (-> self should-play-sound?) #t)
          (when (-> self was-deadly?)
            (set! (-> self was-deadly?) #f)
            (clear-collide-with-as (-> self root-override))
            )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    (none)
    )
  )

(defmethod init-from-entity! caveflamepots ((obj caveflamepots) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> obj was-deadly?) #f)
  (set! (-> obj should-play-sound?) #f)
  (set! (-> obj shove-up) (res-lump-float arg0 'shove :default (meters 5.0)))
  (logclear! (-> obj mask) (process-mask enemy))
  (logclear! (-> obj mask) (process-mask attackable))
  (logior! (-> obj mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 4) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) 0.0 (meters 7) 0.0 (meters 5))
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-0 local-sphere) 0.0 (meters 3) 0.0 (meters 2))
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-1 local-sphere) 0.0 (meters 6) 0.0 (meters 2))
        (append-prim s3-0 s2-1)
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (let ((v1-42 (new 'process 'path-control obj 'path 0.0)))
    (set! (-> obj path) v1-42)
    (logior! (-> v1-42 flags) (path-control-flag display draw-line draw-point draw-text))
    (if (<= (-> v1-42 curve num-cverts) 0)
        (go process-drawable-art-error "no path")
        )
    )
  (let ((f0-23 (res-lump-float arg0 'rotoffset)))
    (if (!= f0-23 0.0)
        (quaternion-rotate-y! (-> obj root-override quat) (-> obj root-override quat) f0-23)
        )
    )
  (let ((f30-0 (quaternion-y-angle (-> obj root-override quat))))
    (let ((s4-1 (-> obj launch-pos)))
      (let ((v1-53 s4-1))
        (set! (-> v1-53 0 x) 0.0)
        (set! (-> v1-53 0 y) 0.0)
        (set! (-> v1-53 0 z) 0.0)
        (set! (-> v1-53 0 w) 1.0)
        )
      (vector-rotate-around-y! (the-as vector s4-1) (the-as vector s4-1) f30-0)
      (vector+! (the-as vector s4-1) (the-as vector s4-1) (-> obj root-override trans))
      )
    (let ((s4-2 (the-as object (&-> obj stack 112))))
      (set-vector! (the-as vector s4-2) -6144.0 0.0 0.0 1.0)
      (vector-rotate-around-y! (the-as vector s4-2) (the-as vector s4-2) f30-0)
      (vector+! (the-as vector s4-2) (the-as vector s4-2) (-> obj root-override trans))
      )
    (let ((s4-3 (-> obj root-override root-prim)))
      (dotimes (s3-1 (-> (the-as collide-shape-prim-group s4-3) num-prims))
        (let ((a1-19 (-> (the-as collide-shape-prim-group s4-3) prims s3-1 local-sphere)))
          (vector-rotate-around-y! a1-19 a1-19 f30-0)
          )
        )
      )
    )
  (update-transforms! (-> obj root-override))
  (let ((f30-1 300.0))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-70 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-16))))
      (set! (-> obj cycle-speed) (the int (* f30-1 (if (and v1-70 (> (the-as int (-> sv-16 elt-count)) 0))
                                                       (-> v1-70 0)
                                                       4.0
                                                       )
                                             )
                                      )
            )
      )
    )
  (let ((f30-2 (the float (-> obj cycle-speed))))
    (set! sv-32 (new 'static 'res-tag))
    (let ((v1-74 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-32))))
      (set! (-> obj cycle-offset)
            (the-as uint (the int (* f30-2 (if (and v1-74 (< 1 (the-as int (-> sv-32 elt-count))))
                                               (-> v1-74 1)
                                               0.0
                                               )
                                     )
                              )
                    )
            )
      )
    )
  (let ((f30-3 300.0))
    (set! sv-48 (new 'static 'res-tag))
    (let ((v1-77 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-48))))
      (set! (-> obj cycle-pause) (the int (* f30-3 (if (and v1-77 (< 2 (the-as int (-> sv-48 elt-count))))
                                                       (-> v1-77 2)
                                                       2.0
                                                       )
                                             )
                                      )
            )
      )
    )
  (go caveflamepots-active)
  (none)
  )

(deftype towertop (process-drawable)
  ((root-override trsq  :offset 112)
   )
  :heap-base #x40
  :method-count-assert 20
  :size-assert         #xb0
  :flag-assert         #x14004000b0
  (:states
    towertop-idle
    )
  )


(defskelgroup *towertop-sg* towertop towertop-lod0-jg towertop-idle-ja
              ((towertop-lod0-mg (meters 20)) (towertop-lod1-mg (meters 40)) (towertop-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 30)
              )

(defstate towertop-idle (towertop)
  :code (behavior ()
    (loop
      (ja-no-eval :group! (-> self draw art-group data 4) :num! (seek! max 0.4) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.4))
        )
      )
    (none)
    )
  :post (the-as (function none :behavior towertop) ja-post)
  )

(defmethod init-from-entity! towertop ((obj towertop) (arg0 entity-actor))
  (logior! (-> obj mask) (process-mask ambient))
  (set! (-> obj root-override) (new 'process 'trsq))
  (process-drawable-from-entity! obj arg0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (initialize-skeleton obj *towertop-sg* '())
  (go towertop-idle)
  (none)
  )

(deftype mayorgears (process-drawable)
  ((alt-actor entity-actor  :offset-assert 176)
   )
  :heap-base #x50
  :method-count-assert 20
  :size-assert         #xb4
  :flag-assert         #x14005000b4
  (:states
    mayorgears-idle
    )
  )


(defskelgroup *mayorgears-sg* mayorgears mayorgears-geo-jg mayorgears-idle-ja
              ((mayorgears-geo-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4.5)
              )

(defstate mayorgears-idle (mayorgears)
  :code (behavior ()
    (loop
      (ja :num! (loop!))
      (ja :num! (loop! 0.0))
      (suspend)
      )
    (none)
    )
  :post (the-as (function none :behavior mayorgears) ja-post)
  )

(defmethod init-from-entity! mayorgears ((obj mayorgears) (arg0 entity-actor))
  (logior! (-> obj mask) (process-mask ambient))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton obj *mayorgears-sg* '())
  (set! (-> obj draw shadow-mask) (the-as uint 255))
  (go mayorgears-idle)
  (none)
  )