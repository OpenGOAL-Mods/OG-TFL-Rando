;;-*-Lisp-*-
(in-package goal)

(defconstant TFL_HINT_DEBUG #t)

(deftype tfl-hint (process-drawable)
  ((sound-to-play string)
   (sphere sphere :inline)
   (last-time time-frame)
   (voicebox handle)
   (task game-task)
   (hint-data tfl-hint-data)
   )
  (:methods
    (debug-draw (_type_) none)
    (debug-print (_type_) none)
    (get-hint-data (_type_) tfl-hint-data)
    (get-sphere-color (_type_) rgba)
    (target-in-sphere? (_type_) symbol)
    (valid-task? (_type_) symbol)
    (check-target-mode (_type_) symbol)
    (can-play? (_type_) symbol)
    )
  (:states
    tfl-hint-idle
    tfl-hint-play
    tfl-hint-wait
    tfl-hint-exit
    )
  )

(define *tfl-hint-playing?* #f)
(define *tfl-hint-semaphore* (the (pointer tfl-hint) #f))

(defun get-tfl-hint ()
  (the tfl-hint (ppointer->process *tfl-hint-semaphore*))
  )

(defmethod deactivate ((this tfl-hint))
  (when (= (get-tfl-hint) this)
    (set! *tfl-hint-semaphore* (the (pointer tfl-hint) #f))
    (false! *tfl-hint-playing?*)
    )
  (call-parent-method this)
  )

(defmethod get-hint-data ((this tfl-hint))
  (dotimes (i (-> *tfl-hints* length))
    ;; (format #t "get-hint-data: item ~D ~S~%" i (-> *tfl-hints* i file-name))
    (if (string= (-> this sound-to-play) (-> *tfl-hints* i file-name))
      (return (the tfl-hint-data (-> *tfl-hints* i)))
      )
    )
  (the tfl-hint-data #f)
  )

(defmethod target-in-sphere? ((this tfl-hint))
  (aif *target*
    (let ((ear (sphere<-vector+r! (new 'stack 'sphere) (ear-trans) 0.0)))
      (spheres-overlap? ear (-> this sphere))
      )
    #f
    )
  )

(defmethod get-sphere-color ((this tfl-hint))
  (cond
    ((= (-> this next-state name) 'tfl-hint-wait) *color-yellow*)
    ((and (target-in-sphere? this) (not (= (get-tfl-hint) this))) *color-magenta*)
    ((and (target-in-sphere? this) (seen-text? *game-info* (-> this hint-data text-id)) (not (-> this hint-data repeat?))) *color-gray*)
    ((= (get-tfl-hint) this) *color-green*)
    (else *color-red*)
    )
  )

(defun anim-playing? ((proc process-drawable) (anim string) (chan-idx int))
  (if (and chan-idx
           (< chan-idx (-> proc skel active-channels))
           (-> proc skel channel chan-idx)
           (nonzero? (-> proc skel channel chan-idx frame-group))
           (string= (-> proc skel channel chan-idx frame-group name) anim)
           )
    #t
    (dotimes (idx (-> proc skel active-channels))
      (let ((ja (if (and (-> proc skel channel idx frame-group)
                         (nonzero? (-> proc skel channel idx frame-group)))
                         (-> proc skel channel idx frame-group))))
        (if (string= (-> ja name) anim)
          (return #t)
          )
        )
      )
    )
  )

(defun pickup-type<-name ((name symbol))
  (case name
    (('eco-blue) (pickup-type eco-blue))
    (('eco-red) (pickup-type eco-red))
    (('eco-green) (pickup-type eco-green))
    (('eco-yellow) (pickup-type eco-yellow))
    (('super-eco-blue) (pickup-type super-eco-blue))
    (('super-eco-red) (pickup-type super-eco-red))
    (('super-eco-green) (pickup-type super-eco-green))
    (('super-eco-yellow) (pickup-type super-eco-yellow))
    (else (pickup-type none))
    )
  )

(defmethod check-target-mode ((this tfl-hint))
  (let ((p (-> this hint-data target-mode)))
    (if (!= '() p)
      (case (car p)
        (('mode)
          (= (send-event *target* 'query 'mode) (cadr p))
          )
        (('powerup)
          (the symbol (send-event *target* 'query 'powerup (pickup-type<-name (the symbol (cadr p)))))
          )
        (('anim)
          (anim-playing? *target* (symbol->string (cadr p)) (the int (cddr p)))
          )
        )
      #t
      )
    )
  )

(defmethod debug-draw ((this tfl-hint))
  (if (>= (meters 50) (vector-vector-distance (target-pos 0) (-> this root trans)))
    (add-debug-text-sphere
      #t
      (bucket-id debug-no-zbuf)
      (-> this sphere)
      (-> this sphere r)
      (string-format "~S id ~X (seen ~A) (task ~D)"
        (-> this hint-data file-name) (-> this hint-data text-id) (seen-text? *game-info* (-> this hint-data text-id)) (-> this task))
      (get-sphere-color this)
      )
    )
  (none)
  )

;; (and (> (-> self task) (game-task none)) (> (-> self hint-data task-status) (task-status invalid)))
(defmethod valid-task? ((this tfl-hint))
  ;; we have a task associated. check if we have a valid task-status as well.
  (if (!= (-> this hint-data task-status) (task-status invalid))
    (= (get-task-status (-> this task)) (-> this hint-data task-status)) ;; we have a valid task-status. check if the task is on that cstage.
    #f
    )
  )

(defmethod can-play? ((this tfl-hint))
  (let ((seen? (seen-text? *game-info* (-> this hint-data text-id)))
        (hint (get-tfl-hint)))
         ;; we are not playing a hint ourselves and there is either no other hint or the current hint can be interrupted 
    (and (and (not (= hint this)) (or (not hint) (-> hint hint-data interrupt?)))
         ;; if we have a task associated, check our task-status and only play then, if task-status is invalid, just play if task is open
         (if (> (-> this task) (game-task none))
           (if (valid-task? this)
             #t
             (not (task-complete? *game-info* (-> this task)))
             )
           #t
           )
         (check-target-mode this)
         ;; either hint was not yet seen or it was seen, can be repeated and the delay has passed
         (or (not seen?) (and seen? (-> this hint-data repeat?) (time-elapsed? (-> this last-time) (-> this hint-data repeat-delay))))
         )
    )
  )

(defmethod init-from-entity! ((this tfl-hint) (ent entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (logior! (-> this mask) (process-mask actor-pause))
  (vector-copy! (-> this root trans) (-> ent extra trans))
  (vector-identity! (-> this root scale))
  (set! (-> this sound-to-play) (aif (res-lump-struct ent 'filename string :time -1000000000.0) it (the string #f)))
  (set! (-> this task) (-> ent task))
  (set! (-> this hint-data) (get-hint-data this))
  (sphere<-vector+r! (-> this sphere) (-> this root trans) (res-lump-float ent 'radius :default (meters 2.5)))
  (set! (-> this voicebox) (the handle #f))
  (if (or (not (-> this hint-data)) (not (-> this sound-to-play)))
    (go process-drawable-art-error "no hint data")
    (go tfl-hint-idle)
    )
  (none)
  )

(defbehavior tfl-hint-init-by-other tfl-hint ((sound string) (pos vector) (r float) (task game-task))
  (set! (-> self root) (new 'process 'trsqv))
  (logior! (-> self mask) (process-mask actor-pause))
  (vector-copy! (-> self root trans) pos)
  (vector-identity! (-> self root scale))
  (set! (-> self sound-to-play) sound)
  (set! (-> self task) task)
  (set! (-> self hint-data) (get-hint-data self))
  (sphere<-vector+r! (-> self sphere) pos r)
  (set! (-> self voicebox) (the handle #f))
  (if (or (not (-> self hint-data)) (not (-> self sound-to-play)))
    (go process-drawable-art-error "no hint data")
    (go tfl-hint-idle)
    )
  (none)
  )


(defbehavior tfl-hint-post tfl-hint ()
  (if TFL_HINT_DEBUG
    (debug-draw self)
    )
  (none)
  )

(defbehavior tfl-hint-event-handler tfl-hint ((proc process) (argc int) (message symbol) (block event-message-block))
  (case message
    (('exit 'die)
      (go tfl-hint-exit)
      )
    (('interrupt)
     (if (-> self hint-data interrupt?)
       (go tfl-hint-idle)
       )
     )
    )
  )

(defstatehandler tfl-hint
  :event tfl-hint-event-handler
  :post tfl-hint-post
  )

(defstate tfl-hint-idle (tfl-hint)
  ;; :enter (behavior ()
  ;;   (if (and (-> self hint-data repeat?) (not (time-elapsed? (-> self last-time) (-> self hint-data repeat-delay))))
  ;;     (go tfl-hint-wait)
  ;;     )
  ;;   )
  :trans (behavior ()
    (if (and (target-in-sphere? self) (can-play? self))
      (go tfl-hint-play)
      )
    )
  :code sleep-code
  )

(defstate tfl-hint-wait (tfl-hint)
  :trans (behavior ()
    (if TFL_HINT_DEBUG
      (format *stdcon* "hint ~A: waiting for delay ~D~%" (-> self name) (- (-> self hint-data repeat-delay) (- (current-time) (-> self last-time))))
      )
    (when (time-elapsed? (-> self last-time) (-> self hint-data repeat-delay))
      (go tfl-hint-idle)
      )
    )
  :code sleep-code
  )

(defstate tfl-hint-play (tfl-hint)
  :enter (behavior ()
    (if (> (-> self hint-data text-id) (text-id zero))
      (mark-text-as-seen *game-info* (-> self hint-data text-id))
      )
    (if (> (-> self hint-data close-task) (game-task none))
      (close-specific-task! (-> self hint-data close-task) (task-status need-resolution))
      )
    (if (and (> (-> self task) (game-task none)) (not (task-complete? *game-info* (-> self task))))
      (go tfl-hint-idle)
      )
    (let ((hint (get-tfl-hint)))
      ;; no hint is playing
      (if (not hint)
        (set! *tfl-hint-semaphore* (the (pointer tfl-hint) (process->ppointer self)))
        )
      ;; hint is playing and cannot be interrupted
      (if (and hint (not (-> hint hint-data interrupt?)))
        (go tfl-hint-idle)
        )
      ;; (if (and hint *tfl-hint-playing?* (not (-> hint hint-data interrupt?)))
      ;;   (go tfl-hint-idle)
      ;;   )
      ;; hint is playing and can be interrupted
      (if (and hint *tfl-hint-playing?* (not (-> hint hint-data interrupt?)))
        (send-event hint 'interrupt)
        )
      )
    )
  :code (behavior ()
    (when (and (or (-> self hint-data force-playback?) (-> *setting-control* current play-hints)) (< 0.0 (-> *setting-control* current dialog-volume)))
      (if (-> self hint-data voicebox?)
        (aif *target* (set! (-> self voicebox) (ppointer->handle (voicebox-spawn it (target-pos 0)))))
        )
      (while (handle->process (-> *game-info* auto-save-proc))
        (suspend)
        )
      (while (not *sound-player-enable*)
        (suspend)
        )
      (set-time! (-> self last-time))
      (play-tfl-hint (-> self hint-data file-name) (-> *setting-control* current dialog-volume) (-> self hint-data interrupt?))
      (dotimes (i 2) (suspend))
      (add-setting! 'music-volume 'rel (-> *setting-control* current music-volume-movie) 0)
      (add-setting! 'sfx-volume 'rel (-> *setting-control* current sfx-volume-movie) 0)
      (add-setting! 'dialog-volume 'rel (-> *setting-control* current dialog-volume-hint) 0)
      (while *tfl-hint-playing?*
        (suspend)
        )
      (if (-> self hint-data repeat?)
        (go tfl-hint-wait)
        )
      )
    (go tfl-hint-idle)
    )
  :exit (behavior ()
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'dialog-volume)
    (when (= (get-tfl-hint) self)
      (set! *tfl-hint-semaphore* (the (pointer tfl-hint) #f))
      )
    (send-event (handle->process (-> self voicebox)) 'die)
    )
  )

(defstate tfl-hint-exit (tfl-hint)
  :code (behavior () (deactivate self))
  )
