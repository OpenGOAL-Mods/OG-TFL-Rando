;;-*-Lisp-*-
(in-package goal)
(require "engine/geometry/vol.gc")
(deftype tfl-cam-control (process-drawable)
  ((cam-pos     vector :inline)
   (move-timer  time-frame)
   (max-y       float)
   (min-y       float)
   (max-z       float)
   (min-z       float)
   (push-z      float)
   (tilt-adjust float)
   (track-speed float)
   (track-accel float))
  (:methods
   (lerp-move-to-vector (_type_ vector vector time-frame) object))
  (:states
   tfl-cam-control-idle
   tfl-cam-control-active
   tfl-cam-control-die))

(defmethod init-from-entity! ((this tfl-cam-control) (e entity-actor))
  (stack-size-set! (-> this main-thread) 512)
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this e)
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this vol) (new 'process 'vol-control this))
  (let ((cam-p (res-lump-struct e 'cam-position vector))
        (move-t (res-lump-float e 'move-timer :default 1.0)))
    (when cam-p
      (set-vector! (-> this cam-pos) (-> cam-p x) (-> cam-p y) (-> cam-p z) 1.0))
    (when move-t
      (set! (-> this move-timer) (the time-frame (seconds move-t)))
      (format 0 "setting move-timer to : ~E ~%" (-> this move-timer))))
  (set! (-> this max-y) (res-lump-float e 'max-y :default (meters 3)))
  (set! (-> this min-y) (res-lump-float e 'min-y :default (meters 1)))
  (set! (-> this max-z) (res-lump-float e 'max-z :default (meters 1235)))
  (set! (-> this min-z) (res-lump-float e 'min-z :default (meters 5)))
  (set! (-> this push-z) (res-lump-float e 'push-z :default (meters 10)))
  (set! (-> this tilt-adjust) (res-lump-float e 'tilt-adjust :default (degrees -6.5000005)))
  (set! (-> this track-speed) (res-lump-float e 'track-speed :default (meters 0.6)))
  (set! (-> this track-accel) (res-lump-float e 'track-accel :default (meters 0.005)))
  (go tfl-cam-control-idle)
  (none))

(defstate tfl-cam-control-idle (tfl-cam-control)
  :enter
    (behavior ()
      (set! (-> *camera* stringMaxHeight) (-> *CAMERA-bank* default-string-max-y))
      (set! (-> *camera* stringMinHeight) (-> *CAMERA-bank* default-string-min-y))
      (set! (-> *camera* stringMaxLength) (-> *CAMERA-bank* default-string-max-z))
      (set! (-> *camera* stringMinLength) (-> *CAMERA-bank* default-string-min-z))
      (set! (-> *camera* string-push-z) (-> *CAMERA-bank* default-string-push-z))
      (set! (-> *camera-combiner* tracking tilt-adjust target) (-> *CAMERA-bank* default-tilt-adjust))
      (set! (-> *CAMERA-bank* default-track-speed) (meters 0.6))
      (set! (-> *CAMERA-bank* default-track-accel) (meters 0.005)))
  :code
    (behavior ()
      (loop
        (if (point-in-vol? (-> self vol) (target-pos 5)) (go tfl-cam-control-active))
        (suspend))))

(defstate tfl-cam-control-active (tfl-cam-control)
  :enter
    (behavior ()
      (set! (-> *camera* stringMaxHeight) (-> self max-y))
      (set! (-> *camera* stringMinHeight) (-> self min-y))
      (set! (-> *camera* stringMaxLength) (-> self max-z))
      (set! (-> *camera* stringMinLength) (-> self min-z))
      (set! (-> *camera* string-push-z) (-> self push-z))
      (set! (-> *camera-combiner* tracking tilt-adjust target) (-> self tilt-adjust))
      (set! (-> *CAMERA-bank* default-track-speed) (-> self track-speed))
      (set! (-> *CAMERA-bank* default-track-accel) (-> self track-accel)))
  :code
    (behavior ()
      (set-time! (-> self state-time))
      (let ((cam (new-stack-vector0)))
        (vector-copy! cam (camera-pos))
        (lerp-move-to-vector self cam (-> self cam-pos) (-> self move-timer)))
      (loop
        (if (not (point-in-vol? (-> self vol) (target-pos 5))) (go tfl-cam-control-idle))
        (suspend))))

(defstate tfl-cam-control-die (tfl-cam-control)
  :enter
    (behavior ())
  :code
    (behavior ()
      (loop
        (suspend))))

(defmethod lerp-move-to-vector ((this tfl-cam-control) (cam-start vector) (cam-target vector) (move-timer time-frame))
  (until (or (time-elapsed? (-> this state-time) move-timer) (not (point-in-vol? (-> this vol) (target-pos 5))))
    (let* ((cam-lerp (new-stack-vector0))
           (timer (/ (the float (- (current-time) (-> this state-time))) TICKS_PER_SECOND))
           (move-timer-float (/ (the float move-timer) TICKS_PER_SECOND))
           (smooth-lerp (+ (* -0.06 (sin (+ (/ timer move-timer-float) TWO_PI))) (/ timer move-timer-float)))
           (slave (aif (ppointer->process (-> *camera* slave 0)) (the camera-slave it) (the camera-slave #f))))
      (false! *camera-read-analog*)
      (vector-lerp! cam-lerp cam-start cam-target smooth-lerp)
      (format *stdcon* "state-time ~E~%" (-> this state-time))
      (format *stdcon* "move-timer ~E~%" move-timer)
      (format *stdcon* "timer ~F~%" timer)
      (format *stdcon* "smooth-lerp ~F~%" smooth-lerp)
      (format *stdcon* "cam-start X ~M Y ~M Z ~M~%" (-> cam-start x) (-> cam-start y) (-> cam-start z))
      (format *stdcon* "cam-target X ~M Y ~M Z ~M~%" (-> cam-target x) (-> cam-target y) (-> cam-target z))
      (format *stdcon* "cam-lerp X ~M Y ~M Z ~M~%" (-> cam-lerp x) (-> cam-lerp y) (-> cam-lerp z))
      (send-event *camera* 'teleport-to-vector cam-lerp))
    (suspend))
  (true! *camera-read-analog*)
  (send-event *camera* 'change-state *camera-base-mode* (seconds 30)))
