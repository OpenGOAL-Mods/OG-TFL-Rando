;;-*-Lisp-*-
(in-package goal)
(deftype rolling-rock-master (process)
  ((path-count       int32)
   (path-array       path-control 8)
   (scale-min        float)
   (scale-max        float)
   (freq-min         float)
   (freq-max         float)
   (speed-min        float)
   (speed-max        float)
   (last-path-picked int32))
  (:methods
   (rolling-rock-master-initialize-paths (_type_) object))
  (:states
   rolling-rock-master-idle))

(defskelgroup *rolling-rock-sg*
  rolling-rock
  rolling-rock-lod0-jg
  rolling-rock-idle-ja
  ((rolling-rock-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 5 0 15))

(deftype rolling-rock (process-drawable)
  ((root                    collide-shape-moving :override)
   (path-speed              float)
   (path-length             float)
   (path-pos                float))
  (:methods
   (init-collision! (_type_ float) object)
   (follow-path (_type_) none))
  (:states
   rolling-rock-rolling
   rolling-rock-explode))

(defmethod init-from-entity! ((this rolling-rock-master) (e entity-actor))
  (logclear! (-> this mask) (process-mask actor-pause))
  (rolling-rock-master-initialize-paths this)
  (go rolling-rock-master-idle)
  (none))

(defbehavior rolling-rock-init-by-other rolling-rock ((e entity-actor) (this rolling-rock) (scale float) (path curve-control) (speed float))
  (set! (-> self path) path)
  (set! (-> self entity) e)
  (set! (-> self path-length) (path-distance (-> self path)))
  (set! (-> self path-speed) (/ 1.0 (/ (-> self path-length) speed)))
  (init-collision! self scale)
  (process-drawable-from-entity! self e)
  (set-vector! (-> self root scale) scale scale scale 1.0)
  (initialize-skeleton self *rolling-rock-sg* '())
  (set-vector! (-> self root trans) 
               (-> self path cverts 0 x)
               (-> self path cverts 0 y)
               (-> self path cverts 0 z)
               (-> self path cverts 0 w))
  (logclear! (-> self mask) (process-mask actor-pause))
  (transform-post)
  (go rolling-rock-rolling)
  (none))

(defmethod follow-path ((this rolling-rock))
  (let* ((pos (-> this root trans))
         (new-pos (vector-copy! (new-stack-vector0) pos)))
    (set! (-> this path-pos)(+ (-> this path-pos) (* (-> this path-speed) (seconds-per-frame))))
    (eval-path-curve! (-> this path) new-pos (-> this path-pos) 'interp)
    (let ((axis (vector-! (new-stack-vector0) pos new-pos))
          (angle (new-stack-quaternion0)))
      (quaternion-zxy! angle axis)
      (quaternion-rotate-local-y! angle angle (vector-y-angle axis))
      (set-quaternion! (-> this root) angle))
    (set-vector! pos (-> new-pos x) (-> new-pos y) (-> new-pos z) (-> new-pos w)))
  (none))

(defmethod init-collision! ((this rolling-rock) (scale float))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) default-collision-reaction)
    (set! (-> cshape no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((csphere (new 'process 'collide-shape-prim-sphere cshape (the-as uint 0))))
      (set! (-> csphere prim-core collide-as) (collide-kind enemy))
      (set! (-> csphere collide-with) (collide-kind target))
      (set! (-> csphere prim-core action) (collide-action solid))
      (set! (-> csphere prim-core offense) (collide-offense indestructible))
      (set-vector! (-> csphere local-sphere) 0.0 (* scale (meters 5.0)) 0.0 (* scale (meters 5.0)))
      (set-root-prim! cshape csphere))
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (backup-collide-with-as cshape)
    (set! (-> this root) cshape))
  (none))

(defmethod rolling-rock-master-initialize-paths ((this rolling-rock-master))
  (let ((paths '(patha pathb pathc pathd pathe pathf pathg pathh))
        (path-counter 0))
    (dotimes (i (length paths))
      (let* ((path-sym (the symbol (ref paths i)))
             (res-path (res-lump-struct (-> this entity) path-sym structure))
             (this-path (-> this path-array path-counter)))
        (when res-path
          (set! (-> this path-array i) (new 'process 'curve-control this path-sym -1000000000.0))
          (logior! (-> this path-array path-counter flags) (path-control-flag display draw-line draw-point draw-text))
          (+! path-counter 1))))
    (set! (-> this path-count) path-counter))
  (set! (-> this scale-min) (res-lump-float (-> this entity) 'scale-min :default 1.0))
  (set! (-> this scale-max) (res-lump-float (-> this entity) 'scale-max :default 1.0))
  (set! (-> this freq-min) (res-lump-float (-> this entity) 'freq-min :default 2.0))
  (set! (-> this freq-max) (res-lump-float (-> this entity) 'freq-max :default 2.0))
  (set! (-> this speed-min) (res-lump-float (-> this entity) 'speed-min :default (meters 20.0)))
  (set! (-> this speed-max) (res-lump-float (-> this entity) 'speed-max :default (meters 25.0)))
  (set! (-> this last-path-picked) 0))

(defmethod relocate ((this rolling-rock-master) (off int))
  (dotimes (i (-> this path-count))
    (if (nonzero? (-> this path-array i)) (&+! (-> this path-array i) off)))
  (call-parent-method this off))

(defstate rolling-rock-master-idle (rolling-rock-master)
  :trans
    (behavior ()
      (when *display-path-marks*
        (dotimes (i (-> self path-count))
          (if (nonzero? (-> self path-array i)) (debug-draw (-> self path-array i))))))
  :code
    (behavior ()
      (loop
        (let ((time-rand (rand-vu-float-range (-> self freq-min) (-> self freq-max)))
              (path-rand (if (> (-> self path-count) 1)
                             (rand-vu-int-range-exclude 1 (-> self path-count) (-> self last-path-picked))
                             1))
              (scale-rand (rand-vu-float-range (-> self scale-min) (-> self scale-max)))
              (speed-rand (rand-vu-float-range (-> self speed-min) (-> self speed-max))))
          (suspend-for (seconds time-rand))
          ;; (format 0 
          ;;         "________________________________~%time-rand: ~F path-rand: ~D~%scale-rand: ~F last-path-picked: ~D~%" 
          ;;         time-rand 
          ;;         path-rand 
          ;;         scale-rand 
          ;;         (-> self last-path-picked))
          (process-spawn rolling-rock 
                         (-> self entity) 
                         self 
                         scale-rand 
                         (-> self path-array (- path-rand 1)) 
                         speed-rand
                         :to *entity-pool*)
          (set! (-> self last-path-picked) path-rand))
        (suspend))))

(defstate rolling-rock-rolling (rolling-rock)
    :enter
      (behavior ()
        (ja :group! rolling-rock-rolling-ja))
    :trans
      (behavior ())
    :code
      (behavior ()
        (loop
          (follow-path self)
          (if (>= (-> self path-pos) 1.0) (go rolling-rock-explode))
          (ja :num! (loop!))
          (suspend)))
    :post transform-post)

(defstate rolling-rock-explode (rolling-rock)
    :code
      (behavior ()
        (loop
          (cleanup-for-death self)
          (deactivate self)
          (suspend))))