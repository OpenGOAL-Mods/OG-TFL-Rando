;;-*-Lisp-*-
(in-package goal)

(import "goal_src/jak1/import/breakaway-right-ag.gc")
(import "goal_src/jak1/import/breakaway-mid-ag.gc")
(import "goal_src/jak1/import/breakaway-left-ag.gc")


(deftype breakaway (process-drawable)
  ((root-override collide-shape-moving :offset 112)
   )
  (:methods
    (init! (_type_ res-lump int) none)
    (go-idle (_type_) none)
    )
  (:states
    breakaway-about-to-fall
    breakaway-fall
    breakaway-idle
    )
  )


(defstate breakaway-idle (breakaway)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (case arg2
      (('touch)
       (send-event arg0 'no-look-around (seconds 1.5))
       (go breakaway-about-to-fall)
       )
      )
    )
  :code (the-as (function none :behavior breakaway) anim-loop)
  :post (the-as (function none :behavior breakaway) transform-post)
  )

(defun actor-wait-for-period ((arg0 time-frame))
  (let ((s5-0 (-> *display* base-frame-counter)))
    (while (< (- (-> *display* base-frame-counter) s5-0) arg0)
      (suspend)
      )
    )
  #f
  )

(defstate breakaway-about-to-fall (breakaway)
  :code (behavior ()
    (sound-play "falling-bones")
    (launch-particles (-> *part-id-table* 281) (-> self root-override trans))              
    (let ((gp-1 #f)
          (s5-1 (-> *display* base-frame-counter))
          )
      (loop
        (ja-no-eval :group! (ja-group) :num! (seek! (ja-aframe 15.0 0)) :frame-num (ja-aframe 1.0 0))
        (until (ja-done? 0)
          (when (and (not gp-1) (>= (- (-> *display* base-frame-counter) s5-1) (seconds 0.15)))
            (set! gp-1 #t)
            (send-to-next-and-prev (-> self link) 'touch)
            )
          (if (>= (- (-> *display* base-frame-counter) s5-1) (seconds 0.25))
              (go breakaway-fall)
              )
          (suspend)
          (ja :num! (seek! (ja-aframe 15.0 0)))
          )
        )
      )
    (none)
    )
  :post (the-as (function none :behavior breakaway) rider-post)
  )

(defstate breakaway-fall (breakaway)
  :code (behavior ()
    (let ((f30-0 0.0)
          (f28-0 0.0)
          (f26-0 (* 0.1 (- (-> *standard-dynamics* gravity-length))))
          )
      (ja-no-eval :group! (ja-group) :num! (seek! (ja-aframe 32.0 0) 0.4) :frame-num (ja-aframe 16.0 0))
      (until (ja-done? 0)
        (+! f30-0 (* f28-0 (-> *display* seconds-per-frame)))
        (+! f28-0 (* f26-0 (-> *display* seconds-per-frame)))
        (+! (-> self root-override trans y) f30-0)
        (suspend)
        (ja :num! (seek! (ja-aframe 32.0 0) 0.4))
        )
      )
    (cleanup-for-death self)
    (none)
    )
  :post (the-as (function none :behavior breakaway) rider-post)
  )

(defmethod init! breakaway ((obj breakaway) (arg0 res-lump) (arg1 int))
  (set! (-> obj mask) (logior (process-mask platform) (-> obj mask)))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s2-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s2-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s2-0 collide-with) (collide-kind target))
      (set! (-> s2-0 prim-core action) (collide-action solid))
      (set! (-> s2-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s2-0 transform-index) arg1)
      (set-vector! (-> s2-0 local-sphere) 8192.0 -4096.0 8192.0 16384.0)
      (set-root-prim! s4-0 s2-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (set! (-> obj link) (new 'process 'actor-link-info obj))
  (process-drawable-from-entity! obj (the-as entity-actor arg0))
  (none)
  )

(defmethod go-idle breakaway ((obj breakaway))
  (go breakaway-idle)
  (none)
  )

(deftype breakaway-right (breakaway)
  ()
  )


(deftype breakaway-mid (breakaway)
  ()
  )


(deftype breakaway-left (breakaway)
  ()
  )


(defskelgroup *breakaway-right-sg* breakaway-right breakaway-right-lod0-jg breakaway-right-idle-ja
              ((breakaway-right-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7)
              )

(defskelgroup *breakaway-mid-sg* breakaway-mid breakaway-mid-lod0-jg breakaway-mid-idle-ja
              ((breakaway-mid-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7)
              )

(defskelgroup *breakaway-left-sg* breakaway-left breakaway-left-lod0-jg breakaway-left-idle-ja
              ((breakaway-left-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7)
              )

(defmethod init-from-entity! breakaway-right ((obj breakaway-right) (arg0 entity-actor))
  (init! obj arg0 3)
  (initialize-skeleton obj *breakaway-right-sg* '())
  (go-idle obj)
  (none)
  )

(defmethod init-from-entity! breakaway-mid ((obj breakaway-mid) (arg0 entity-actor))
  (init! obj arg0 3)
  (initialize-skeleton obj *breakaway-mid-sg* '())
  (go-idle obj)
  (none)
  )

(defmethod init-from-entity! breakaway-left ((obj breakaway-left) (arg0 entity-actor))
  (init! obj arg0 3)
  (initialize-skeleton obj *breakaway-left-sg* '())
  (go-idle obj)
  (none)
  )

(deftype electric-arc (process-drawable)
  ((root-override      collide-shape           :offset        112)
   (shove-up           float                   :offset-assert 176)
   (cycle-speed        int32                   :offset-assert 180)
   (cycle-pause        int32                   :offset-assert 184)
   (cycle-offset       uint32                  :offset-assert 188)
   (was-deadly?        symbol                  :offset-assert 192)
   (should-play-sound? symbol                  :offset-assert 196)
   (launch-pos         vector        2 :inline :offset-assert 208)
   )
  :heap-base #x80
  :method-count-assert 20
  :size-assert         #xf0
  :flag-assert         #x14008000f0
  (:states
    electric-arc-active
    )
  )


(defpart 704 ;; Edit particles to some electric stuff
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 1.0)
    (:scale-x (meters 2))
    (:rot-z (degrees -180) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 0.0)
    (:a 128.0)
    (:vel-y (meters 0.04) (meters 0.01))
    (:scalevel-x (meters -0.0039999997))
    (:rotvel-z (degrees -1.8) (degrees 1.8))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -1.28)
    (:fade-a -0.85333335)
    (:accel-y (meters -0.0006))
    (:timer (seconds 16.68))
    (:flags (bit2 bit3))
    )
  )

(defpart 705
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 1.0)
    (:scale-x (meters 2))
    (:rot-z (degrees -180) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 0.0)
    (:a 128.0)
    (:vel-y (meters 0.04) (meters 0.01))
    (:scalevel-x (meters -0.0039999997))
    (:rotvel-z (degrees -1.8) (degrees 1.8))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -1.28)
    (:fade-a -0.85333335)
    (:accel-y (meters -0.0006))
    (:timer (seconds 16.68))
    (:flags (bit2 bit3))
    )
  )

(defstate electric-arc-active (electric-arc)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch 'attack)
       (when (= (-> proc type) target)
         (when ((method-of-type touching-shapes-entry prims-touching-action?)
                (the-as touching-shapes-entry (-> event param 0))
                (-> *target* control)
                (collide-action solid)
                (collide-action)
                )
           (let ((s4-0 (new 'stack 'attack-info)))
             (calc-shove-up (-> self root-override) s4-0 (-> self shove-up))
             (if (or (= (-> *target* control unknown-surface00 mode) 'air)
                     (>= (+ (-> *display* base-frame-counter) (seconds -0.2)) (-> *target* control unknown-dword11))
                     (< 0.75 (-> *target* control poly-normal y))
                     )
                 (send-event
                   proc
                   'attack-or-shove
                   (-> event param 0)
                   (static-attack-info ((mode 'burn) (vector (-> s4-0 vector)) (shove-up (-> s4-0 shove-up))))
                   )
                 (send-event
                   proc
                   'attack-or-shove
                   (-> event param 0)
                   (static-attack-info ((mode 'burn)
                                        (shove-up (meters 0))
                                        (shove-back (meters 2))
                                        (vector (-> *target* control poly-normal))
                                        (angle 'shove)
                                        )
                                       )
                   )
                 )
             )
           )
         )
       )
      )
    )
  :trans (behavior ()
    (let* ((v1-0 (-> self cycle-speed))
           (a0-1 (- v1-0 (-> self cycle-pause)))
           (gp-0 (mod (+ (-> *display* base-frame-counter) (the-as time-frame (-> self cycle-offset))) v1-0))
           )
      (cond
        ((< gp-0 a0-1)
         (when (sphere-in-view-frustum? (the-as sphere (-> self root-override root-prim prim-core)))
           (launch-particles (-> *part-id-table* 704) (the-as vector (-> self launch-pos)))
           (launch-particles (-> *part-id-table* 705) (the-as vector (&-> self stack 112)))
           )
         (when (-> self should-play-sound?)
           (set! (-> self should-play-sound?) #f)
           (sound-play "hot-flame") ;; TFL todo: change sound to some electric stuff
           )
         (cond
           ((< gp-0 30)
            (when (-> self was-deadly?)
              (set! (-> self was-deadly?) #f)
              (clear-collide-with-as (-> self root-override))
              )
            )
           (else
             (when (not (-> self was-deadly?))
               (set! (-> self was-deadly?) #t)
               (restore-collide-with-as (-> self root-override))
               )
             )
           )
         (when (and (not (-> self was-deadly?)) (< 60 gp-0))
           (set! (-> self was-deadly?) #t)
           (restore-collide-with-as (-> self root-override))
           )
         )
        (else
          (set! (-> self should-play-sound?) #t)
          (when (-> self was-deadly?)
            (set! (-> self was-deadly?) #f)
            (clear-collide-with-as (-> self root-override))
            )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    (none)
    )
  )

(defmethod init-from-entity! electric-arc ((obj electric-arc) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> obj was-deadly?) #f)
  (set! (-> obj should-play-sound?) #f)
  (set! (-> obj shove-up) (res-lump-float arg0 'shove :default 8192.0))
  (logclear! (-> obj mask) (process-mask enemy))
  (logclear! (-> obj mask) (process-mask attackable))
  (logior! (-> obj mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player)))) ;; Vectors for hitbox
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 4) 0))) 
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) (meters 0.0) (meters 0.0) (meters 0.0) (meters 4.0))
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-0 local-sphere) (meters 0.0) (meters 0.0) (meters 0.0) (meters 4.0))
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-1 local-sphere) (meters -0.30) (meters 5.99) (meters -0.05) (meters 4.0))
        (append-prim s3-0 s2-1)
        )
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-2 local-sphere) (meters -0.60) (meters 11.98) (meters -0.11) (meters 4.0))
        (append-prim s3-0 s2-2)
        )
      (let ((s2-3 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-3 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-3 collide-with) (collide-kind target))
        (set! (-> s2-3 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-3 local-sphere) (meters -0.91) (meters 17.97) (meters -0.17) (meters 4.0))
        (append-prim s3-0 s2-3)
        )
      (let ((s2-4 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-4 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-4 collide-with) (collide-kind target))
        (set! (-> s2-4 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-4 local-sphere) (meters -1.21) (meters 23.96) (meters -0.23) (meters 4.0))
        (append-prim s3-0 s2-4)
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (let ((v1-42 (new 'process 'path-control obj 'path 0.0)))
    (set! (-> obj path) v1-42)
    (logior! (-> v1-42 flags) (path-control-flag display draw-line draw-point draw-text))
    (if (<= (-> v1-42 curve num-cverts) 0)
        (go process-drawable-art-error "no path")
        )
    )
  (let ((f0-23 (res-lump-float arg0 'rotoffset)))
    (if (!= f0-23 0.0)
        (quaternion-rotate-y! (-> obj root-override quat) (-> obj root-override quat) f0-23)
        )
    )
  (let ((f30-0 (quaternion-y-angle (-> obj root-override quat))))
    (let ((s4-1 (-> obj launch-pos)))
      (let ((v1-53 s4-1))
        (set! (-> v1-53 0 x) 6144.0)
        (set! (-> v1-53 0 y) 0.0)
        (set! (-> v1-53 0 z) 0.0)
        (set! (-> v1-53 0 w) 1.0)
        )
      (vector-rotate-around-y! (the-as vector s4-1) (the-as vector s4-1) f30-0)
      (vector+! (the-as vector s4-1) (the-as vector s4-1) (-> obj root-override trans))
      )
    (let ((s4-2 (the-as object (&-> obj stack 112))))
      (set-vector! (the-as vector s4-2) -6144.0 0.0 0.0 1.0)
      (vector-rotate-around-y! (the-as vector s4-2) (the-as vector s4-2) f30-0)
      (vector+! (the-as vector s4-2) (the-as vector s4-2) (-> obj root-override trans))
      )
    (let ((s4-3 (-> obj root-override root-prim)))
      (dotimes (s3-1 (-> (the-as collide-shape-prim-group s4-3) num-prims))
        (let ((a1-19 (-> (the-as collide-shape-prim-group s4-3) prims s3-1 local-sphere)))
          (vector-rotate-around-y! a1-19 a1-19 f30-0)
          )
        )
      )
    )
  (update-transforms! (-> obj root-override))
  (let ((f30-1 300.0))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-70 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-16))))
      (set! (-> obj cycle-speed) (the int (* f30-1 (if (and v1-70 (> (the-as int (-> sv-16 elt-count)) 0))
                                                       (-> v1-70 0)
                                                       4.0
                                                       )
                                             )
                                      )
            )
      )
    )
  (let ((f30-2 (the float (-> obj cycle-speed))))
    (set! sv-32 (new 'static 'res-tag))
    (let ((v1-74 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-32))))
      (set! (-> obj cycle-offset)
            (the-as uint (the int (* f30-2 (if (and v1-74 (< 1 (the-as int (-> sv-32 elt-count))))
                                               (-> v1-74 1)
                                               0.0
                                               )
                                     )
                              )
                    )
            )
      )
    )
  (let ((f30-3 300.0))
    (set! sv-48 (new 'static 'res-tag))
    (let ((v1-77 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-48))))
      (set! (-> obj cycle-pause) (the int (* f30-3 (if (and v1-77 (< 2 (the-as int (-> sv-48 elt-count))))
                                                       (-> v1-77 2)
                                                       2.0
                                                       )
                                             )
                                      )
            )
      )
    )
  (go electric-arc-active)
  (none)
  )