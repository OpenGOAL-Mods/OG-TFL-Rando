;;-*-Lisp-*-
(in-package goal)

(defskelgroup *electric-arc-sg*
  money
  money-lod0-jg
  money-idle-ja
  ((money-lod0-mg (meters 20)) (money-lod1-mg (meters 40)) (money-lod2-mg (meters 999999)))
  :bounds (static-spherem 0 3 0 4)
  :texture-level 2)

(deftype electric-arc (process-drawable)
  ((cshape             collide-shape :overlay-at root)
   (shove-up           float)
   (cycle-speed        int32)
   (cycle-pause        int32)
   (cycle-offset       uint32)
   (was-deadly?        symbol)
   (should-play-sound? symbol)
   (launch-pos         vector 2 :inline))
  (:states
   electric-arc-active))

(defstate electric-arc-active (electric-arc)
  :event
    (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
      (case event-type
        (('touch 'attack)
         (when (= (-> proc type) target)
           (when (prims-touching-action? (the touching-shapes-entry (-> event param 0))
                                         (-> *target* control)
                                         (collide-action solid)
                                         (collide-action))
             (let ((s4-0 (new 'stack 'attack-info)))
               (calc-shove-up (-> self cshape) s4-0 (-> self shove-up))
               (if (or (= (-> *target* control unknown-surface00 mode) 'air)
                       (>= (+ (-> *display* base-frame-counter) (seconds -0.2)) (-> *target* control unknown-dword11))
                       (< 0.75 (-> *target* control poly-normal y)))
                 (send-event proc
                             'attack-or-shove
                             (-> event param 0)
                             (static-attack-info ((mode 'burn) (vector (-> s4-0 vector)) (shove-up (-> s4-0 shove-up)))))
                 (send-event proc
                             'attack-or-shove
                             (-> event param 0)
                             (static-attack-info ((mode 'burn) (shove-up (meters 0)) (shove-back (meters 2)) (vector (-> *target* control poly-normal)) (angle 'shove)))))))))))
  :trans
    (behavior ()
      (let* ((v1-0 (-> self cycle-speed))
             (a0-1 (- v1-0 (-> self cycle-pause)))
             (gp-0 (mod (+ (current-time) (the time-frame (-> self cycle-offset))) v1-0)))
        (cond
          ((< gp-0 a0-1)
           (when (sphere-in-view-frustum? (the sphere (-> self cshape root-prim prim-core)))
             (launch-particles (-> *part-id-table* 3048) (the vector (-> self launch-pos))) ;; Moved to crystalc-part.gc
             (launch-particles (-> *part-id-table* 3049) (the vector (-> self launch-pos)))
             (launch-particles (-> *part-id-table* 3050) (the vector (-> self launch-pos)))
             (launch-particles (-> *part-id-table* 3051) (the vector (-> self launch-pos)))
             (launch-particles (-> *part-id-table* 3052) (the vector (-> self launch-pos)))
             (launch-particles (-> *part-id-table* 3053) (the vector (-> self launch-pos)))
             (launch-particles (-> *part-id-table* 3054) (the vector (-> self launch-pos))))
           (awhen (level-get *level* 'crystal-ca)
                  (set-vector! *crystalc-ship-dir2* 0.3 0.4 1.6 1.0)
                  (set-vector! *crystalc-ship-ambi* 0.1 0.3 0.6 1.0))
           (update! (-> self sound))
           (update-vol! (-> self sound) 160)
           (cond
             ((-> self should-play-sound?)
              (set! (-> self should-play-sound?) #f)
              ;; (update-vol! (-> self sound) 1500)
              ))
           (cond
             ((< gp-0 30) (when (-> self was-deadly?) (set! (-> self was-deadly?) #f) (clear-collide-with-as (-> self cshape))))
             (else (when (not (-> self was-deadly?)) (set! (-> self was-deadly?) #t) (restore-collide-with-as (-> self cshape)))))
           (when (and (not (-> self was-deadly?)) (< 60 gp-0))
             (set! (-> self was-deadly?) #t)
             (restore-collide-with-as (-> self cshape))))
          (else
           (set! (-> self should-play-sound?) #t)
           (update-vol! (-> self sound) 1)
           (awhen (level-get *level* 'crystal-ca)
                  (set-vector! *crystalc-ship-dir2* 1.5 0.0 1.2 1.0)
                  (set-vector! *crystalc-ship-ambi* 0.2 0.2 0.7 1.0))
           (when (-> self was-deadly?)
             (set! (-> self was-deadly?) #f)
             (clear-collide-with-as (-> self cshape))))))
      (none))
  :code
    (behavior ()
      (loop
        (logior! (-> self mask) (process-mask sleep-code))
        (suspend))
      (none))
  :post
    (behavior ()
      (ja-post)
      (logior! (-> self draw status) (draw-status hidden))
      (none)))

(defmethod init-from-entity! electric-arc
  ((this electric-arc) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> this was-deadly?) #f)
  (set! (-> this should-play-sound?) #f)
  (set! (-> this shove-up) (res-lump-float arg0 'shove :default 8192.0))
  (logclear! (-> this mask) (process-mask enemy))
  (logclear! (-> this mask) (process-mask attackable))
  (logior! (-> this mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player)))) ;; Vectors for hitbox
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the uint 12) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) (meters 0.0) (meters 12.0) (meters 0.0) (meters 24.0))
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-0 local-sphere) (meters 0.0) (meters 0.0) (meters 0.0) (meters 4.0))
        (append-prim s3-0 s2-0))
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-1 local-sphere) (meters -0.30) (meters 5.99) (meters -0.05) (meters 4.0))
        (append-prim s3-0 s2-1))
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-2 local-sphere) (meters -0.60) (meters 11.98) (meters -0.11) (meters 4.0))
        (append-prim s3-0 s2-2))
      (let ((s2-3 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-3 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-3 collide-with) (collide-kind target))
        (set! (-> s2-3 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-3 local-sphere) (meters -0.91) (meters 17.97) (meters -0.17) (meters 4.0))
        (append-prim s3-0 s2-3))
      (let ((s2-4 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-4 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-4 collide-with) (collide-kind target))
        (set! (-> s2-4 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-4 local-sphere) (meters -1.21) (meters 23.96) (meters -0.23) (meters 4.0))
        (append-prim s3-0 s2-4))
      (let ((s2-5 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-5 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-5 collide-with) (collide-kind target))
        (set! (-> s2-5 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-5 local-sphere) (meters -7.86) (meters 24.37) (meters -1.60) (meters 3.0))
        (append-prim s3-0 s2-5))
      (let ((s2-6 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-6 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-6 collide-with) (collide-kind target))
        (set! (-> s2-6 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-6 local-sphere) (meters -9.83) (meters 19.28) (meters -1.93) (meters 3.0))
        (append-prim s3-0 s2-6))
      (let ((s2-7 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-7 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-7 collide-with) (collide-kind target))
        (set! (-> s2-7 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-7 local-sphere) (meters -11.76) (meters 14.28) (meters -2.26) (meters 3.0))
        (append-prim s3-0 s2-7))
      (let ((s2-8 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-8 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-8 collide-with) (collide-kind target))
        (set! (-> s2-8 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-8 local-sphere) (meters -13.75) (meters 9.14) (meters -2.59) (meters 3.0))
        (append-prim s3-0 s2-8))
      (let ((s2-9 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-9 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-9 collide-with) (collide-kind target))
        (set! (-> s2-9 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-9 local-sphere) (meters 5.69) (meters 24.37) (meters 1.16) (meters 3.0))
        (append-prim s3-0 s2-9))
      (let ((s2-10 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-10 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-10 collide-with) (collide-kind target))
        (set! (-> s2-10 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-10 local-sphere) (meters 8.65) (meters 22.09) (meters 1.76) (meters 3.0))
        (append-prim s3-0 s2-10))
      (let ((s2-11 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-11 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-11 collide-with) (collide-kind target))
        (set! (-> s2-11 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-11 local-sphere) (meters 11.62) (meters 19.81) (meters 2.36) (meters 3.0))
        (append-prim s3-0 s2-11)))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this cshape) s4-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *electric-arc-sg* '())
  (set! (-> this sound)
        (new 'process
             'ambient-sound
             (static-sound-spec "blue-eco-idle" :fo-min 30 :fo-max 100 :volume 1500)
             (-> this cshape trans)))
  ;; (logior! (-> this draw status) (draw-status hidden))
  (let ((v1-42 (new 'process 'path-control this 'path 0.0)))
    (set! (-> this path) v1-42)
    (logior! (-> v1-42 flags) (path-control-flag display draw-line draw-point draw-text))
    (if (<= (-> v1-42 curve num-cverts) 0) (go process-drawable-art-error "no path")))
  (let ((f0-23 (res-lump-float arg0 'rotoffset)))
    (if (!= f0-23 0.0) (quaternion-rotate-y! (-> this cshape quat) (-> this cshape quat) f0-23)))
  (let ((f30-0 (quaternion-y-angle (-> this cshape quat))))
    (let ((s4-1 (-> this launch-pos)))
      (let ((v1-53 s4-1))
        (set! (-> v1-53 0 x) 6144.0)
        (set! (-> v1-53 0 y) 0.0)
        (set! (-> v1-53 0 z) 0.0)
        (set! (-> v1-53 0 w) 1.0))
      (vector-rotate-around-y! (the vector s4-1) (the vector s4-1) f30-0)
      (vector+! (the vector s4-1) (the vector s4-1) (-> this cshape trans)))
    (let ((s4-2 (the object (&-> this stack 112))))
      (set-vector! (the vector s4-2) -6144.0 0.0 0.0 1.0)
      (vector-rotate-around-y! (the vector s4-2) (the vector s4-2) f30-0)
      (vector+! (the vector s4-2) (the vector s4-2) (-> this cshape trans)))
    (let ((s4-3 (-> this cshape root-prim)))
      (dotimes (s3-1 (-> (the collide-shape-prim-group s4-3) num-prims))
        (let ((a1-19 (-> (the collide-shape-prim-group s4-3) prims s3-1 local-sphere)))
          (vector-rotate-around-y! a1-19 a1-19 f30-0)))))
  (update-transforms! (-> this cshape))
  (let ((f30-1 300.0))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-70 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-16))))
      (set! (-> this cycle-speed) (the int (* f30-1 (if (and v1-70 (> (the int (-> sv-16 elt-count)) 0)) (-> v1-70 0) 4.0))))))
  (let ((f30-2 (the float (-> this cycle-speed))))
    (set! sv-32 (new 'static 'res-tag))
    (let ((v1-74 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-32))))
      (set! (-> this cycle-offset)
            (the uint (the int (* f30-2 (if (and v1-74 (< 1 (the int (-> sv-32 elt-count)))) (-> v1-74 1) 0.0)))))))
  (let ((f30-3 300.0))
    (set! sv-48 (new 'static 'res-tag))
    (let ((v1-77 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-48))))
      (set! (-> this cycle-pause) (the int (* f30-3 (if (and v1-77 (< 2 (the int (-> sv-48 elt-count)))) (-> v1-77 2) 2.0))))))
  (go electric-arc-active)
  (none))

(defun can-ride-gondola? ()
  (and (task-closed? (game-task crystalc-middle) (task-status need-resolution))
       (task-closed? (game-task crystalc-river) (task-status need-resolution))
       (task-closed? (game-task crystalc-ship) (task-status need-resolution))
       (task-closed? (game-task crystalc-shrooms) (task-status need-resolution))
       (task-closed? (game-task crystalc-hidden) (task-status need-resolution))
       (task-closed? (game-task crystalc-buzzer) (task-status need-resolution))))

(defun set-camera-bank ((arg0 symbol))
  (case arg0
    (('reset)
     ; (format 0 "reset camera-bank ~%")
     (set! (-> *CAMERA-bank* default-track-speed) (meters 0.6))
     (set! (-> *CAMERA-bank* default-track-accel) (meters 0.005))
     (set! (-> *CAMERA-bank* default-string-min-y) (meters 1))
     (set! (-> *CAMERA-bank* default-string-max-y) (meters 3))
     (set! (-> *CAMERA-bank* default-tilt-adjust) (degrees -6.5000005)))
    (('up)
     ; (format 0 "up camera-bank ~%")
     (set! (-> *CAMERA-bank* default-track-speed) (meters 5))
     (set! (-> *CAMERA-bank* default-track-accel) (meters 0.5))
     (set! (-> *CAMERA-bank* default-string-min-y) (meters 3))
     (set! (-> *CAMERA-bank* default-string-max-y) (meters 5))
     (set! (-> *CAMERA-bank* default-tilt-adjust) (degrees 5)))
    (('down)
     ; (format 0 "down camera-bank ~%")
     (set! (-> *CAMERA-bank* default-track-speed) (meters 5))
     (set! (-> *CAMERA-bank* default-track-accel) (meters 0.5))
     (set! (-> *CAMERA-bank* default-string-min-y) (meters 2))
     (set! (-> *CAMERA-bank* default-string-max-y) (meters 4))
     (set! (-> *CAMERA-bank* default-tilt-adjust) (degrees -10)))))

(defskelgroup *crc-gondola-sg*
  crc-gondola
  crc-gondola-lod0-jg
  crc-gondola-idle-bottom-ja
  ((crc-gondola-lod0-mg (meters 9999999)))
  :bounds (static-spherem 0 5 0 12))

(deftype crc-gondola (process-drawable)
  ((root          collide-shape-moving :override)
   (touching-time time-frame)
   (bottom-pos    vector :inline)
   (top-pos       vector :inline))
  (:methods
   (init-collision! (_type_) object)
   (toggle-invis-walls (_type_ symbol) object)
   (closest-pos (_type_) symbol))
  (:states
   crc-gondola-idle-bottom
   crc-gondola-idle-top
   crc-gondola-going-up
   crc-gondola-going-down))

(defbehavior set-gondola-light crc-gondola ((mode symbol))
  (let ((bottom-dir (static-vector -0.18 -0.08 -0.15 1.0))
        (top-dir (static-vector 0.65 0.60 0.3 1.0))
        (bottom-ambi (static-vector -0.05 0.08 0.0 1.0))
        (top-ambi (static-vector 0.50 0.50 0.50 1.0))
        (lerp-dir (new-stack-vector0))
        (lerp-ambi (new-stack-vector0))
        (ja-frame (ja-aframe-num 0)))
    (case mode
      (('idle-bottom)
       (vector-copy! *crystalc-crc-gondola-dir2* bottom-dir)
       (vector-copy! *crystalc-crc-gondola-ambi* bottom-ambi))
      (('idle-top) (vector-copy! *crystalc-crc-gondola-dir2* top-dir) (vector-copy! *crystalc-crc-gondola-ambi* top-ambi))
      (('going-up)
       (let ((frame-start 400.0)
             (frame-end 750.0))
         (when (> ja-frame frame-start)
           (vector-lerp-clamp! lerp-dir bottom-dir top-dir (/ (- ja-frame frame-start) (- frame-end frame-start)))
           (vector-copy! *crystalc-crc-gondola-dir2* lerp-dir)
           (vector-lerp-clamp! lerp-ambi bottom-ambi top-ambi (/ (- ja-frame frame-start) (- frame-end frame-start)))
           (vector-copy! *crystalc-crc-gondola-ambi* lerp-ambi))))
      (('going-down)
       (let ((frame-start 200.0)
             (frame-end 600.0))
         (when (< ja-frame (+ frame-end frame-start))
           (vector-lerp-clamp! lerp-dir top-dir bottom-dir (/ (- ja-frame frame-start) frame-end))
           (vector-copy! *crystalc-crc-gondola-dir2* lerp-dir)
           (vector-lerp-clamp! lerp-ambi top-ambi bottom-ambi (/ (- ja-frame frame-start) frame-end))
           (vector-copy! *crystalc-crc-gondola-ambi* lerp-ambi)))))))

(defmethod closest-pos ((this crc-gondola))
  (when (not *target*)
    (return 'bottom))
  (let ((bottom-dist (vector-vector-distance (-> *target* control trans) (-> this bottom-pos)))
        (top-dist (vector-vector-distance (-> *target* control trans) (-> this top-pos))))
    (if (< bottom-dist top-dist) 'bottom 'top)))

(defmethod toggle-invis-walls ((this crc-gondola) (mode symbol))
  (mlet ((INVIS_WALL_PRIM_IDX 8))
        (case mode
          (('on)
           (set-collide-with! (-> (the collide-shape-prim-group (-> this root root-prim)) prims INVIS_WALL_PRIM_IDX)
                              (collide-kind target))
           (set-collide-as! (-> (the collide-shape-prim-group (-> this root root-prim)) prims INVIS_WALL_PRIM_IDX)
                            (collide-kind ground-object)))
          (('off)
           (set-collide-with! (-> (the collide-shape-prim-group (-> this root root-prim)) prims INVIS_WALL_PRIM_IDX)
                              (collide-kind enemy))
           (set-collide-as! (-> (the collide-shape-prim-group (-> this root root-prim)) prims INVIS_WALL_PRIM_IDX)
                            (collide-kind target))))))

(defmethod init-collision! ((this crc-gondola))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) default-collision-reaction)
    (set! (-> cshape no-reaction) (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (alloc-riders cshape 1)
    (let ((cgroup (new 'process 'collide-shape-prim-group cshape (the uint 9) 0)))
      (set! (-> cgroup prim-core collide-as) (collide-kind ground-object))
      (set! (-> cgroup collide-with) (collide-kind target))
      (set! (-> cgroup prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> cgroup transform-index) 5)
      (set-vector! (-> cgroup local-sphere) 0.0 (meters 4) 0.0 (meters 12))
      (set-root-prim! cshape cgroup)
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 0) (the uint 0)))) ;; Wood platform
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 5)
        (set-vector! (-> mesh local-sphere) 0.0 (meters 0) 0.0 (meters 60.0))
        (append-prim cgroup mesh))
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 1) (the uint 1)))) ;; Platform walls
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 5)
        (set-vector! (-> mesh local-sphere) 0.0 (meters 0) 0.0 (meters 7.0))
        (append-prim cgroup mesh))
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 2) (the uint 2)))) ;; Right chain
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 5)
        (set-vector! (-> mesh local-sphere) (meters 5) (meters 3) (meters 0.0) (meters 7.0))
        (append-prim cgroup mesh))
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 3) (the uint 3)))) ;; Left chain
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 5)
        (set-vector! (-> mesh local-sphere) (meters -5) (meters 3) (meters 0.0) (meters 7.0))
        (append-prim cgroup mesh))
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 4) (the uint 16)))) ;; Lever base
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 5)
        (set-vector! (-> mesh local-sphere) (meters 3.5) (meters 0) (meters 0.0) (meters 2.0))
        (append-prim cgroup mesh))
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 5) (the uint 5)))) ;; Axis
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 5)
        (set-vector! (-> mesh local-sphere) (meters 0) (meters 10) (meters 0.0) (meters 6.5))
        (append-prim cgroup mesh))
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 6) (the uint 6)))) ;; Right wheel
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 5)
        (set-vector! (-> mesh local-sphere) (meters 6) (meters 10) (meters 0.0) (meters 3.5))
        (append-prim cgroup mesh))
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 7) (the uint 7)))) ;; Left wheel
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 5)
        (set-vector! (-> mesh local-sphere) (meters -6) (meters 10) (meters 0.0) (meters 3.5))
        (append-prim cgroup mesh))
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 8) (the uint 8)))) ;; inside walls
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 5)
        (set-vector! (-> mesh local-sphere) 0.0 (meters 3.5) 0.0 (meters 10))
        (append-prim cgroup mesh)))
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (backup-collide-with-as cshape)
    (set! (-> this root) cshape)))

(defmethod init-from-entity! ((this crc-gondola) (e entity-actor))
  (init-collision! this) ;; allocate root and set up prim group
  (process-drawable-from-entity! this e) ;; copy position and rotation from entity
  (initialize-skeleton this *crc-gondola-sg* '()) ;; set up draw-control
  (set! (-> this draw origin-joint-index) 5)
  (vector-copy! (-> this bottom-pos) (static-vectorm -300 90 45))
  (vector-copy! (-> this top-pos) (static-vectorm -263 210 320))
  (logior! (-> this skel status) (janim-status inited))
  (transform-post) ;; update our root transform
  (set! (-> this sound) (new 'process 'ambient-sound (static-sound-spec "lava-pulley" :fo-max 100) (-> this root trans)))
  (case (closest-pos this)
    (('bottom) (go crc-gondola-idle-bottom))
    (('top) (go crc-gondola-idle-top)))
  (none))

(defevent crc-gondola-event-handler
          crc-gondola
          (case message
            (('ridden)
             (if (zero? (-> self touching-time)) (set-time! (-> self touching-time)))
             (let ((idle? (symbol-member? (-> self next-state name) '(crc-gondola-idle-bottom crc-gondola-idle-top)))
                   (fnt (new 'stack 'font-context *font-default-matrix* 32 160 0.0 (font-color default) (font-flags shadow kerning))))
               (when (and (not (can-ride-gondola?)) (time-elapsed? (-> self touching-time) (seconds 1.5)))
                 (close-specific-task! (game-task crystalc-gondola) (task-status need-introduction))
                 (set-width! fnt 448)
                 (set-height! fnt 80)
                 (set-scale! fnt 0.8)
                 (set-flags! fnt (font-flags shadow kerning middle large))
                 (print-game-text (lookup-text! *common-text* (text-id crystalc-gondola-need-cells) #f) fnt #f 128 22))))
            (('attack)
             (when (and (can-ride-gondola?) (= (-> proc type) target))
               (let ((tshapes (the touching-shapes-entry (-> block param 0)))
                     (attack (-> block param 1))
                     (state (-> self next-state name))
                     (LEVER_PRIM_ID (the uint 16)))
                 (case attack
                   (('spin)
                    (if (and tshapes (prims-touching? tshapes (-> self root) LEVER_PRIM_ID))
                      (case state
                        (('crc-gondola-idle-bottom) (go crc-gondola-going-up))
                        (('crc-gondola-idle-top) (go crc-gondola-going-down)))))))))))

(defbehavior crc-gondola-post crc-gondola ()
  (let ((target-rider? (and (nonzero? (-> self root riders num-riders))
                            (= *target* (handle->process (-> self root riders rider 0 rider-handle))))))
    (when target-rider?
      (cond
        ((and (= (-> self next-state name) 'crc-gondola-going-up) (< (ja-aframe-num 0) 800.0)) (set-camera-bank 'up))
        ((and (= (-> self next-state name) 'crc-gondola-going-down) (< (ja-aframe-num 0) 800.0)) (set-camera-bank 'down))
        (else (set-camera-bank 'reset))))
    (when (not target-rider?)
      (set! (-> self touching-time) (seconds 0))
      (if (symbol-member? (-> self next-state name) '(crc-gondola-going-down crc-gondola-going-up)) (set-camera-bank 'reset))))
  (rider-post))

(defstatehandler crc-gondola :event crc-gondola-event-handler :trans rider-trans :post crc-gondola-post)

(defstate crc-gondola-idle-bottom (crc-gondola)
  :enter
    (behavior ()
      (toggle-invis-walls self 'off)
      (set-gondola-light 'idle-bottom)
      (update-vol! (-> self sound) 1)
      (update! (-> self sound)))
  :code
    (behavior ()
      (ja :group! crc-gondola-idle-bottom-ja)
      (loop
        (if (= (closest-pos self) 'top) (go crc-gondola-going-up))
        (ja :num! (loop!))
        (suspend))))

(defstate crc-gondola-idle-top (crc-gondola)
  :enter
    (behavior ()
      (toggle-invis-walls self 'off)
      (set-gondola-light 'idle-top)
      (update-vol! (-> self sound) 1)
      (update! (-> self sound)))
  :code
    (behavior ()
      (ja :group! crc-gondola-idle-top-ja)
      (loop
        (if (= (closest-pos self) 'bottom) (go crc-gondola-going-down))
        (ja :num! (loop!))
        (suspend))))

(defstate crc-gondola-going-up (crc-gondola)
  :enter
    (behavior ()
      (sound-play "close-orb-cash"
                  :vol 100
                  :pitch -0.2
                  :position
                  (the symbol (vector<-cspace! (new-stack-vector0) (joint-node crc-gondola-lod0-jg lever))))
      (toggle-invis-walls self 'on)
      (update-vol! (-> self sound) 80)
      (when (and (not (task-closed? (game-task crystalc-gondola) (task-status need-resolution))) (can-ride-gondola?))
        (close-specific-task! (game-task crystalc-gondola) (task-status need-resolution))))
  :code
    (behavior ()
      (ja :group! crc-gondola-going-up-ja :num! min)
      (until (ja-done? 0)
        (ja :num! (seek! max))
        (when (>= (ja-aframe-num 0) 810.0)
          (toggle-invis-walls self 'off))
        (set-gondola-light 'going-up)
        (update-trans! (-> self sound) (vector<-cspace! (new-stack-vector0) (joint-node crc-gondola-lod0-jg axis)))
        (update! (-> self sound))
        (suspend))
      (go crc-gondola-idle-top)))

(defstate crc-gondola-going-down (crc-gondola)
  :enter
    (behavior ()
      (sound-play "close-orb-cash"
                  :vol 100
                  :pitch -0.2
                  :position
                  (the symbol (vector<-cspace! (new-stack-vector0) (joint-node crc-gondola-lod0-jg lever))))
      (update-vol! (-> self sound) 80)
      (toggle-invis-walls self 'on))
  :code
    (behavior ()
      (ja :group! crc-gondola-going-down-ja :num! min)
      (until (ja-done? 0)
        (ja :num! (seek! max))
        (when (>= (ja-aframe-num 0) 800.0)
          (toggle-invis-walls self 'off))
        (set-gondola-light 'going-down)
        (update-trans! (-> self sound) (vector<-cspace! (new-stack-vector0) (joint-node crc-gondola-lod0-jg axis)))
        (update! (-> self sound))
        (suspend))
      (go crc-gondola-idle-bottom)))
