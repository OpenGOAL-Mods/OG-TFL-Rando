;;-*-Lisp-*-
(in-package goal)

(defpartgroup group-misty-bone-01
  :id 192
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 24)
  :parts ((sp-item 914 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 915 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 916 :period (seconds 2.6) :length (seconds 0.215))
    (sp-item 917 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 918 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 919 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 920 :period (seconds 2.6) :length (seconds 0.107) :offset 65056)
    (sp-item 921 :period (seconds 2.6) :length (seconds 0.107) :offset 64996)
    )
  )

(defpart 921
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 187))
    )
  )

(defpart 920
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters 2.5))
    (:y (meters 1) (meters 1))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.006666667) (meters 0.013333334))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters 0.000033333334))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 80) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 187))
    )
  )

(defpart 919
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 187))
    )
  )

(defpart 918
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 0.05) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 64.0 32.0)
    (:vel-x (meters -0.026666667) (meters 0.013333334))
    (:vel-y (meters -0.013333334) (meters 0.053333335))
    (:vel-z (meters -0.033333335) (meters 0.06666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:accel-y (meters -0.0016666667))
    (:friction 0.996)
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:next-time (seconds 0.3))
    (:next-launcher 922)
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 187))
    )
  )

(defpart 922
  :init-specs ((:fade-a -1.0666667))
  )

(defpart 917
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:y (meters -1) (meters 1.5))
    (:z (meters -5) (meters 10))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.026666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 4) (meters 16))
    (:rotate-y (degrees 187))
    )
  )

(defpart 914
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:y (meters 1) (meters 1))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.006666667) (meters 0.013333334))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters 0.000033333334))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 80) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 140))
    )
  )

(defpart 915
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:y (meters 1) (meters 1))
    (:scale-x (meters 0.05) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 64.0 32.0)
    (:vel-y (meters 0.04) (meters 0.026666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:accel-y (meters -0.0016666667))
    (:friction 0.996)
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:next-time (seconds 0.3))
    (:next-launcher 923)
    (:conerot-x (degrees 70) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 140))
    )
  )

(defpart 923
  :init-specs ((:fade-a -3.2))
  )

(defpart 916
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 2.0)
    (:x (meters -3.5) (meters 4.5))
    (:y (meters 1) (meters 12))
    (:z (meters -3) (meters 6))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 8.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.017777778)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:rotate-y (degrees 187))
    )
  )

(defpartgroup group-misty-bone-03
  :id 193
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 24)
  :parts ((sp-item 914 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 915 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 924 :period (seconds 2.6) :length (seconds 0.215))
    (sp-item 925 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 926 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 927 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 928 :period (seconds 2.6) :length (seconds 0.107) :offset 65056)
    (sp-item 929 :period (seconds 2.6) :length (seconds 0.107) :offset 64996)
    )
  )

(defpart 929
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpart 928
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters 2.5))
    (:y (meters 1) (meters 1))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.006666667) (meters 0.013333334))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters 0.000033333334))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 80) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpart 927
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpart 926
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 0.05) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 64.0 32.0)
    (:vel-x (meters -0.026666667) (meters 0.013333334))
    (:vel-y (meters -0.013333334) (meters 0.053333335))
    (:vel-z (meters -0.033333335) (meters 0.06666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:accel-y (meters -0.0016666667))
    (:friction 0.996)
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:next-time (seconds 0.3))
    (:next-launcher 922)
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpart 925
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:y (meters -1) (meters 1.5))
    (:z (meters -5) (meters 10))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.026666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 4) (meters 16))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpart 924
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 2.0)
    (:x (meters -3.5) (meters 4.5))
    (:y (meters 1) (meters 12))
    (:z (meters -3) (meters 6))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 8.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.017777778)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpartgroup group-misty-bone-02
  :id 194
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 24)
  :parts ((sp-item 914 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 915 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 930 :period (seconds 2.6) :length (seconds 0.215))
    (sp-item 931 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 932 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 933 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 934 :period (seconds 2.6) :length (seconds 0.107) :offset 65056)
    (sp-item 935 :period (seconds 2.6) :length (seconds 0.107) :offset 64996)
    )
  )

(defpart 935
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 114))
    )
  )

(defpart 934
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters 2.5))
    (:y (meters 1) (meters 1))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.006666667) (meters 0.013333334))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters 0.000033333334))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 80) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 114))
    )
  )

(defpart 933
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 114))
    )
  )

(defpart 932
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 0.05) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 64.0 32.0)
    (:vel-x (meters -0.026666667) (meters 0.013333334))
    (:vel-y (meters -0.013333334) (meters 0.053333335))
    (:vel-z (meters -0.033333335) (meters 0.06666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:accel-y (meters -0.0016666667))
    (:friction 0.996)
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:next-time (seconds 0.3))
    (:next-launcher 922)
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 114))
    )
  )

(defpart 931
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:y (meters -1) (meters 1.5))
    (:z (meters -5) (meters 10))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.026666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -90))
    (:conerot-radius (meters 4) (meters 16))
    (:rotate-y (degrees 114))
    )
  )

(defpart 930
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 2.0)
    (:x (meters -3.5) (meters 4.5))
    (:y (meters 1) (meters 12))
    (:z (meters -3) (meters 6))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 8.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.017777778)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:rotate-y (degrees 114))
    )
  )

(defpartgroup group-misty-bone-07
  :id 195
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 24)
  :parts ((sp-item 914 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 915 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 936 :period (seconds 2.6) :length (seconds 0.215))
    (sp-item 937 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 938 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 939 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 940 :period (seconds 2.6) :length (seconds 0.107) :offset 65056)
    (sp-item 941 :period (seconds 2.6) :length (seconds 0.107) :offset 64966)
    )
  )

(defpart 941
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 14.000005))
    )
  )

(defpart 940
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters 2.5))
    (:y (meters 1) (meters 1))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.006666667) (meters 0.013333334))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters 0.000033333334))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 80) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 14.000005))
    )
  )

(defpart 939
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 14.000005))
    )
  )

(defpart 938
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 0.05) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 64.0 32.0)
    (:vel-x (meters -0.026666667) (meters 0.013333334))
    (:vel-y (meters -0.013333334) (meters 0.053333335))
    (:vel-z (meters -0.033333335) (meters 0.06666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:accel-y (meters -0.0016666667))
    (:friction 0.996)
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:next-time (seconds 0.3))
    (:next-launcher 922)
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 14.000005))
    )
  )

(defpart 937
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:y (meters -1) (meters 1.5))
    (:z (meters -5) (meters 10))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.026666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -90))
    (:conerot-radius (meters 4) (meters 16))
    (:rotate-y (degrees 14.000005))
    )
  )

(defpart 936
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 2.0)
    (:x (meters -3.5) (meters 4.5))
    (:y (meters 1) (meters 12))
    (:z (meters -3) (meters 6))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 8.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.017777778)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:rotate-y (degrees 14.000005))
    )
  )

(deftype mis-bone-bridge (process-drawable)
  ((root              collide-shape-moving :override)
   (particle-group    sparticle-launch-group)
   (player-attack-id  int32)
   (fall-anim-index   int32)
   (hit-points        int8)
   )
  (:states
    mis-bone-bridge-bump
    (mis-bone-bridge-fall symbol)
    mis-bone-bridge-hit
    mis-bone-bridge-idle
    )
  )


(defskelgroup *mis-bone-bridge-sg* mis-bone-bridge mis-bone-bridge-lod0-jg mis-bone-bridge-idle-ja
              ((mis-bone-bridge-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 15 0 40)
              )

(defbehavior mis-bone-bridge-event-handler mis-bone-bridge ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (let ((s5-0 (-> arg3 param 2))
           (gp-0 (vector-x-quaternion! (new-stack-vector0) (-> self root quat)))
           (a0-4 (vector-z-quaternion! (new-stack-vector0) (-> self root quat)))
           (v1-4 (vector-! (new-stack-vector0) (-> *target* control trans) (-> self root trans)))
           )
       0.0
       0.0
       (when (!= s5-0 (-> self player-attack-id))
         (set! (-> self player-attack-id) (the-as int s5-0))
         (let ((f0-3 (vector-dot gp-0 v1-4))
               (f1-1 (vector-dot a0-4 v1-4))
               )
           (cond
             ((and (< 0.0 f1-1) (< (fabs (* 0.5 f0-3)) f1-1))
              (if (send-event *target* 'query 'powerup (pickup-type eco-red))
                  (go mis-bone-bridge-fall #f)
                  (go mis-bone-bridge-hit)
                  )
              )
             (else
               (go mis-bone-bridge-bump)
               #f
               )
             )
           )
         )
       )
     )
    )
  )

(defstate mis-bone-bridge-idle (mis-bone-bridge)
  :event mis-bone-bridge-event-handler
  :code (behavior ()
    (ja :num-func num-func-identity :frame-num 0.0)
    (loop
      (if (and *target* (>= 32768.0 (vector-vector-distance (-> self root trans) (-> *target* control trans))))
          (level-hint-spawn
            (text-id misty-bone-bridge-hint)
            "sksp0435"
            (the-as entity #f)
            *entity-pool*
            (game-task none)
            )
          )
      (suspend)
      )
    )
  :post transform-post
  )

(defstate mis-bone-bridge-bump (mis-bone-bridge)
  :event mis-bone-bridge-event-handler
  :trans rider-trans
  :code (behavior ()
    (ja-no-eval :group! mis-bone-bridge-bumped-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go mis-bone-bridge-idle)
    )
  :post rider-post
  )

(defstate mis-bone-bridge-hit (mis-bone-bridge)
  :event mis-bone-bridge-event-handler
  :trans rider-trans
  :code (behavior ()
    (+! (-> self hit-points) -1)
    (if (zero? (-> self hit-points))
        (go mis-bone-bridge-fall #f)
        )
    (ja-no-eval :group! mis-bone-bridge-kicked-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go mis-bone-bridge-idle)
    )
  :post rider-post
  )

(defstate mis-bone-bridge-fall (mis-bone-bridge)
  :trans rider-trans
  :code (behavior ((arg0 symbol))
    (process-entity-status! self (entity-perm-status complete) #t)
    (when (not arg0)
      (process-spawn
        part-tracker
        :init part-tracker-init
        (-> self particle-group)
        -1
        #f
        #f
        #f
        (-> self root trans)
        :to *entity-pool*
        )
      (ja-no-eval :group! (-> self draw art-group data (-> self fall-anim-index)) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (ja :group! (-> self draw art-group data (-> self fall-anim-index))
        :num! (identity (the float (+ (-> (ja-group) data 0 length) -1)))
        )
    (loop
      (suspend)
      )
    )
  :post rider-post
  )

(defmethod init-from-entity! ((this mis-bone-bridge) (arg0 entity-actor))
  (logior! (-> this mask) (process-mask platform))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-others))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid attackable attackable-unused))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 (* 98304.0 (res-lump-value arg0 'scale float)) )
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core action) (collide-action solid))
        (set! (-> s2-0 prim-core offense) (collide-offense indestructible))
        (set! (-> s2-0 transform-index) 0)
        (set-vector! (-> s2-0 local-sphere) 0.0 0.0 0.0 (* 9011.2 (res-lump-value arg0 'scale float)))
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core action) (collide-action solid))
        (set! (-> s2-1 prim-core offense) (collide-offense indestructible))
        (set! (-> s2-1 transform-index) 4)
        (set-vector! (-> s2-1 local-sphere) 0.0 49152.0 0.0 (* 49152.0 (res-lump-value arg0 'scale float)))
        (append-prim s3-0 s2-1)
        )
      )
    (set! (-> s4-0 nav-radius) (* (* 0.75 (-> s4-0 root-prim local-sphere w)) (res-lump-value arg0 'scale float)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *mis-bone-bridge-sg* '())
  (let ((v1-40 (res-lump-value arg0 'animation-select uint128)))
    (cond
      ((= (the-as uint v1-40) 1)
       (set! (-> this fall-anim-index) 2)
       (set! (-> this particle-group) (-> *part-group-id-table* 192))
       )
      ((= (the-as uint v1-40) 2)
       (set! (-> this fall-anim-index) 3)
       (set! (-> this particle-group) (-> *part-group-id-table* 194))
       )
      ((= (the-as uint v1-40) 3)
       (set! (-> this fall-anim-index) 2)
       (set! (-> this particle-group) (-> *part-group-id-table* 193))
       )
      ((= (the-as uint v1-40) 7)
       (set! (-> this fall-anim-index) 4)
       (set! (-> this particle-group) (-> *part-group-id-table* 195))
       )
      (else
        (set! (-> this fall-anim-index) 2)
        (set! (-> this particle-group) (-> *part-group-id-table* 192))
        )
      )
    )
  (set! (-> this hit-points) 3)
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status complete)))
      (go mis-bone-bridge-fall #t)
      (go mis-bone-bridge-idle)
      )
  (none)
  )

(define *bone-platform-constants* (new 'static 'rigid-body-platform-constants
                                    :drag-factor 2.0
                                    :buoyancy-factor 5.0
                                    :max-buoyancy-depth (meters 2)
                                    :gravity-factor 1.0
                                    :gravity (meters 80)
                                    :player-weight (meters 15)
                                    :player-bonk-factor 1.0
                                    :player-dive-factor 1.0
                                    :player-force-distance (meters 1000)
                                    :player-force-clamp (meters 1000000)
                                    :player-force-timeout (seconds 0.1)
                                    :explosion-force (meters 1000)
                                    :linear-damping 1.0
                                    :angular-damping 1.0
                                    :control-point-count 5
                                    :mass 2.0
                                    :inertial-tensor-x (meters 3)
                                    :inertial-tensor-y (meters 2)
                                    :inertial-tensor-z (meters 3)
                                    :cm-joint-y (meters -3)
                                    :idle-distance (meters 50)
                                    :platform #t
                                    :sound-name "mud-plat"
                                    )
        )

(deftype bone-platform (rigid-body-platform)
  ((anchor-point  vector  :inline)
   )
  )


(defskelgroup *mis-bone-platform-sg* mis-bone-platform mis-bone-platform-lod0-jg mis-bone-platform-idle-ja
              ((mis-bone-platform-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defmethod rigid-body-platform-method-27 ((this bone-platform) (arg0 vector))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (vector-! gp-0 arg0 (-> this rbody position))
    (set! (-> gp-0 y) 0.0)
    (let* ((f0-1 (vector-length gp-0))
           (f1-1 (* 20.0 (fmax 0.0 (fmin 4096.0 (+ -819.2 f0-1)))))
           )
      (when (< 0.0 f1-1)
        (vector-float*! gp-0 gp-0 (/ f1-1 f0-1))
        (rigid-body-method-15 (-> this rbody) gp-0)
        )
      )
    )
  0
  (none)
  )

(defmethod rigid-body-platform-method-23 ((this bone-platform) (arg0 float))
  (call-parent-method this arg0)
  (rigid-body-platform-method-27 this (-> this anchor-point))
  0
  (none)
  )

(defstate rigid-body-platform-idle (bone-platform)
  :virtual #t
  :enter (behavior ()
    (ja-channel-set! 0)
    )
  :code (behavior ()
    (loop
      (suspend)
      )
    )
  :post ja-post
  )

(defstate rigid-body-platform-float (bone-platform)
  :virtual #t
  :event rigid-body-platform-event-handler
  :trans (behavior ()
    (-> self entity extra trans y)
    (cond
      ((or (not *target*) (< (-> self info idle-distance)
                             (vector-vector-distance (-> self root-overlay trans) (-> *target* control trans))
                             )
           )
       (let ((f30-1 -4096.0))
         (seek! (-> self float-height-offset) f30-1 (* 2048.0 (seconds-per-frame)))
         (if (= (-> self float-height-offset) f30-1)
             (go-virtual rigid-body-platform-idle)
             )
         )
       )
      (else
        (seek! (-> self float-height-offset) 4096.0 (* 2048.0 (seconds-per-frame)))
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! mis-bone-platform-idle-ja)
    (ja :num-func num-func-identity :frame-num 0.0)
    (loop
      (suspend)
      )
    )
  :post rigid-body-platform-post
  )

(defmethod rigid-body-platform-method-30 ((this bone-platform))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root-overlay) s5-0)
    )
  0
  (none)
  )

(defmethod rigid-body-platform-method-31 ((this bone-platform))
  (initialize-skeleton this *mis-bone-platform-sg* '())
  (rigid-body-platform-method-29 this *bone-platform-constants*)
  (set! (-> this float-height-offset) -4096.0)
  (if (name= (-> this name) "bone-platform-5")
      (set-vector! (-> this root-overlay scale) 0.8 1.0 0.8 1.0)
      )
  (let ((s5-0 (-> this info control-point-count)))
    (dotimes (s4-0 s5-0)
      (let ((s3-0 (-> this control-point-array data s4-0)))
        (let ((f30-0 (* 65536.0 (/ (the float s4-0) (the float s5-0)))))
          (set! (-> s3-0 local-pos x) (* 12288.0 (sin f30-0)))
          (set! (-> s3-0 local-pos y) -12288.0)
          (set! (-> s3-0 local-pos z) (* 12288.0 (cos f30-0)))
          )
        (set! (-> s3-0 local-pos w) 1.0)
        )
      )
    )
  (set! (-> this anchor-point quad) (-> this root-overlay trans quad))
  0
  (none)
  )

(defskelgroup *citb-button-sg* citb-button citb-button-lod0-jg citb-button-idle-ja
              ((citb-button-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(deftype citb-button (basebutton)
  ()
  )


(defmethod basebutton-method-27 ((this citb-button))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0)
    )
  (the-as collide-shape-moving 0)
  )

(defmethod basebutton-method-26 ((this citb-button))
  (initialize-skeleton this *citb-button-sg* '())
  (logior! (-> this skel status) (janim-status inited))
  (ja-channel-set! 1)
  (cond
    ((-> this down?)
     (let ((s5-0 (-> this skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-0
         (the-as art-joint-anim (-> this draw art-group data 2))
         num-func-identity
         )
       (set! (-> s5-0 frame-num)
             (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 2)) data 0 length) -1))
             )
       )
     )
    (else
      (let ((s5-1 (-> this skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-1
          (the-as art-joint-anim (-> this draw art-group data 2))
          num-func-identity
          )
        (set! (-> s5-1 frame-num) 0.0)
        )
      )
    )
  (set! (-> this anim-speed) 2.0)
  (set! (-> this timeout) 1.0)
  (update-transforms! (-> this root))
  (ja-post)
  (none)
  )

(defskelgroup *citb-drop-plat-sg* citb-drop-plat citb-drop-plat-lod0-jg citb-drop-plat-idle-ja
              ((citb-drop-plat-lod0-mg (meters 20)) (citb-drop-plat-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *citb-drop-plat-red-sg* citb-drop-plat citb-drop-plat-red-lod0-jg citb-drop-plat-red-idle-ja
              ((citb-drop-plat-red-lod0-mg (meters 20)) (citb-drop-plat-red-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *citb-drop-plat-green-sg* citb-drop-plat citb-drop-plat-green-lod0-jg citb-drop-plat-green-idle-ja
              ((citb-drop-plat-green-lod0-mg (meters 20)) (citb-drop-plat-green-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *citb-drop-plat-blue-sg* citb-drop-plat citb-drop-plat-blue-lod0-jg citb-drop-plat-blue-idle-ja
              ((citb-drop-plat-blue-lod0-mg (meters 20)) (citb-drop-plat-blue-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *citb-drop-plat-yellow-sg* citb-drop-plat citb-drop-plat-yellow-lod0-jg citb-drop-plat-yellow-idle-ja
              ((citb-drop-plat-yellow-lod0-mg (meters 20)) (citb-drop-plat-yellow-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(deftype tfl-drop-plat (process-drawable)
  ((root        collide-shape-moving :override)
   (spin-axis   vector                :inline)
   (spin-angle  float)
   (spin-speed  float)
   (interp      float)
   (duration    time-frame)
   (delay       time-frame)
   (color       int32) ;; TFL note: changed from int8 to get lump to work
   )
  (:methods
    (tfl-drop-plat-method-20 (_type_) none)
    (tfl-drop-plat-method-21 (_type_) none)
    )
  (:states
    tfl-drop-plat-die
    tfl-drop-plat-drop
    tfl-drop-plat-idle
    (tfl-drop-plat-rise draw-control)
    tfl-drop-plat-spawn
    )
  )


(defstate tfl-drop-plat-idle (tfl-drop-plat)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('drop)
       (logclear! (-> self mask) (process-mask actor-pause))
       (go tfl-drop-plat-drop)
       )
      (('touch) ;; TFL note: removed 'attack so they only drop on touch
       (send-event *target* 'no-look-around (seconds 1))
       (send-event (ppointer->process (-> self parent)) 'player-stepped (-> self color))
       #f
       )
      )
    )
  :code (behavior ()
    (suspend)
    (update-transforms! (-> self root))
    (set-time! (-> self state-time))
    (logior! (-> self mask) (process-mask actor-pause))
    (loop
      (if (time-elapsed? (-> self state-time) (-> self duration))
          (go tfl-drop-plat-drop)
          )
      (suspend)
      )
    )
  :post ja-post
  )

(defbehavior tfl-drop-plat-set-fade tfl-drop-plat ()
  (let ((f0-1
          (fmin
            1.0
            (* 0.000012207031
               (- (-> self root trans y) (+ -204800.0 (-> (the-as process-drawable (-> self parent 0)) root trans y)))
               )
            )
          )
        )
    (set-vector! (-> self draw color-mult) f0-1 f0-1 f0-1 1.0)
    )
  0
  (none)
  )

(defstate tfl-drop-plat-spawn (tfl-drop-plat)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('drop)
       (go tfl-drop-plat-die)
       )
      )
    )
  :code (behavior ()
    (set! (-> self root trans y) (+ -204800.0 (-> (the-as process-drawable (-> self parent 0)) root trans y)))
    (logior! (-> self draw status) (draw-status hidden))
    (ja-post)
    (set-time! (-> self state-time))
    (loop
      (when (time-elapsed? (-> self state-time) (-> self delay))
        (let ((v1-14 (logclear (-> self draw status) (draw-status hidden)))
              (a0-5 (-> self draw))
              )
          (set! (-> a0-5 status) v1-14)
          (go tfl-drop-plat-rise a0-5)
          )
        )
      (suspend)
      )
    )
  )

(defstate tfl-drop-plat-rise (tfl-drop-plat)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('drop)
       (go tfl-drop-plat-drop)
       )
      )
    )
  :code (behavior ((arg0 draw-control))
    (set! (-> self interp) 1.0)
    (set-time! (-> self state-time))
    (set! (-> self spin-angle) 0.0)
    (set! (-> self root trans y) (+ -204800.0 (-> (the-as process-drawable (-> self parent 0)) root trans y)))
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (s5-0 #f)
          )
      (set! (-> gp-0 quad) (-> self root trans quad))
      (set! (-> gp-0 y) (-> (the-as process-drawable (-> self parent 0)) root trans y))
      (loop
        (let ((f0-6 (fmax 0.0 (- 1.0 (* 0.0033333334 (the float (- (current-time) (-> self state-time))))))))
          (set! (-> self interp) (* f0-6 f0-6))
          )
        (set! (-> self root trans y)
              (- (-> (the-as process-drawable (-> self parent 0)) root trans y) (* 204800.0 (-> self interp)))
              )
        (when (and (not s5-0) (< (-> self interp) 0.05))
          (set! s5-0 #t)
          (sound-play "bridge-piece-up" :position (the-as symbol gp-0))
          )
        (set! (-> self spin-angle) (* 10.0 (-> self spin-speed) (-> self interp)))
        (if (= (-> (the-as process-drawable (-> self parent 0)) root trans y) (-> self root trans y))
            (go tfl-drop-plat-idle)
            )
        (suspend)
        )
      )
    )
  :post (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'quaternion)))
      (quaternion-vector-angle! gp-0 (-> self spin-axis) (-> self spin-angle))
      (quaternion*! (-> self root quat) (-> (the-as process-drawable (-> self parent 0)) root quat) gp-0)
      )
    (tfl-drop-plat-set-fade)
    (transform-post)
    )
  )

(defstate tfl-drop-plat-drop (tfl-drop-plat)
  :code (behavior ()
    (when (= (-> (the-as process-drawable (-> self parent 0)) root trans y) (-> self root trans y))
      (set-time! (-> self state-time))
      (sound-play "bridge-piece-dn")
      (let ((gp-1 (the int (* (* (res-lump-float (-> self entity) 'wiggle-time :default 1.0) 300.0) (rand-vu-float-range 0.2 0.3))))) ;; tfl note: added this as a res-lump
        (while (not (time-elapsed? (-> self state-time) gp-1))
          (set! (-> self interp) (/ (the float (- (current-time) (-> self state-time))) (the float gp-1)))
          (set! (-> self spin-angle) (* 910.2222 (sin (* 196608.0 (-> self interp)))))
          (suspend)
          )
        )
      )
    (loop
      (vector-v++! (-> self root transv) (compute-acc-due-to-gravity (-> self root) (new-stack-vector0) 0.0))
      (vector-v++! (-> self root trans) (-> self root transv))
      (if (< 204800.0 (- (-> (the-as process-drawable (-> self parent 0)) root trans y) (-> self root trans y)))
          (go tfl-drop-plat-die)
          )
      (+! (-> self spin-angle) (* (-> self spin-speed) (seconds-per-frame)))
      (suspend)
      )
    )
  :post (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'quaternion)))
      (quaternion-vector-angle! gp-0 (-> self spin-axis) (-> self spin-angle))
      (quaternion*! (-> self root quat) (-> (the-as process-drawable (-> self parent 0)) root quat) gp-0)
      )
    (tfl-drop-plat-set-fade)
    (transform-post)
    )
  )

(defstate tfl-drop-plat-die (tfl-drop-plat)
  :code (behavior ()
    (cleanup-for-death self)
    )
  )

(defmethod tfl-drop-plat-method-20 ((this tfl-drop-plat))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod tfl-drop-plat-method-21 ((this tfl-drop-plat))
  (case (-> this color)
    ((1)
     (initialize-skeleton this *citb-drop-plat-red-sg* '())
     )
    ((2)
     (initialize-skeleton this *citb-drop-plat-green-sg* '())
     )
    ((3)
     (initialize-skeleton this *citb-drop-plat-blue-sg* '())
     )
    ((4)
     (initialize-skeleton this *citb-drop-plat-yellow-sg* '())
     )
    (else
      (initialize-skeleton this *citb-drop-plat-sg* '())
      )
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (let ((s3-0 (new 'stack-no-clear 'vector))
        (s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s3-0 x) (* 65536.0 (rand-vu)))
    (let ((f30-1 14563.556)
          (f0-2 (rand-vu-float-range -1.0 1.0))
          )
      (set! (-> s3-0 y) (* f30-1 (* f0-2 f0-2)))
      )
    (vector-sincos! s5-0 s4-0 s3-0)
    (set! (-> this spin-axis x) (* (-> s4-0 y) (-> s4-0 x)))
    (set! (-> this spin-axis y) (-> s5-0 y))
    (set! (-> this spin-axis z) (* (-> s4-0 y) (-> s5-0 x)))
    )
  (set! (-> this spin-axis w) 1.0)
  (set! (-> this spin-angle) 0.0)
  (set! (-> this spin-speed) (* 8192.0 (+ 1.0 (rand-vu))))
  0
  (none)
  )

(defbehavior tfl-drop-plat-init-by-other tfl-drop-plat ((arg0 vector) (arg1 time-frame) (arg2 time-frame) (arg3 int))
  (set! (-> self color) arg3)
  (set! (-> self delay) arg1)
  (set! (-> self duration) arg2)
  (tfl-drop-plat-method-20 self)
  (set! (-> self root trans quad) (-> arg0 quad))
  (vector-identity! (-> self root scale))
  (quaternion-copy! (-> self root quat) (-> (the-as process-drawable (-> self parent 0)) root quat))
  (tfl-drop-plat-method-21 self)
  (go tfl-drop-plat-spawn)
  (none)
  )

(deftype handle-inline-array (inline-array-class)
  ((data  handle  :dynamic)
   )
  )


(set! (-> handle-inline-array heap-base) (the-as uint 8))

(deftype tfl2-drop-plat (process-drawable)
  ((x-count            int32)
   (z-count            int32)
   (child-count        int32)
   (child-array        handle-inline-array)
   (child-color-array  (pointer int32)) ;; TFL note: changed from int8 to get lump to work
   (x-dir              vector  :inline)
   (z-dir              vector  :inline)
   (origin             vector  :inline)
   (x-spacing          float)
   (z-spacing          float)
   (idle-distance      float)
   (duration           time-frame)
   (drop-time          time-frame)
   )
  (:states
    tfl2-drop-plat-active
    tfl2-drop-plat-idle
    )
  )


(defmethod relocate ((this tfl2-drop-plat) (arg0 int))
  (if (nonzero? (-> this child-array))
      (&+! (-> this child-array) arg0)
      )
  (the-as tfl2-drop-plat ((method-of-type process-drawable relocate) this arg0))
  )

(defbehavior tfl2-drop-plat-spawn-children tfl2-drop-plat ()
  (local-vars (s0-0 int) (sv-48 process) (sv-64 int))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    6
    0
    (let ((s5-0 0)
          (s4-0 1)
          )
      (when (< 0.0
               (vector-dot (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> self root trans)) (-> self z-dir))
               )
        (set! s5-0 (+ (-> self z-count) -1))
        (set! s4-0 -1)
        )
      (dotimes (s3-2 (-> self z-count))
        (dotimes (s2-0 (-> self x-count))
          (let ((s1-0 (+ s2-0 (* s5-0 (-> self x-count)))))
            (set! (-> gp-0 quad) (-> self origin quad))
            (vector+*! gp-0 gp-0 (-> self x-dir) (* (-> self x-spacing) (the float s2-0)))
            (vector+*! gp-0 gp-0 (-> self z-dir) (* (-> self z-spacing) (the float s5-0)))
            (if (-> self child-color-array)
                (set! s0-0 (-> self child-color-array s1-0))
                (set! s0-0 (rand-vu-int-range 0 5))
                )
            (when (nonzero? s0-0)
              (set! sv-64 (the int (* 150.0 (rand-vu))))
              (set! sv-48 (get-process *default-dead-pool* tfl-drop-plat #x4000))
              (set! (-> self child-array data s1-0)
                    (ppointer->handle (when sv-48
                                        (let ((t9-6 (method-of-type tfl-drop-plat activate)))
                                          (t9-6 (the-as tfl-drop-plat sv-48) self 'drop-plat (the-as pointer #x70004000))
                                          )
                                        (let ((t9-7 run-function-in-process)
                                              (a0-8 sv-48)
                                              (a1-5 tfl-drop-plat-init-by-other)
                                              (a2-4 gp-0)
                                              (t0-0 (-> self duration))
                                              )
                                          ((the-as (function process function vector int int int none) t9-7)
                                           a0-8
                                           a1-5
                                           a2-4
                                           sv-64
                                           (the-as int t0-0)
                                           s0-0
                                           )
                                          )
                                        (-> sv-48 ppointer)
                                        )
                                      )
                    )
              )
            )
          )
        (let ((s2-1 (current-time)))
          (until (time-elapsed? s2-1 (seconds 0.12))
            (suspend)
            )
          )
        (+! s5-0 s4-0)
        )
      )
    )
  (set-time! (-> self drop-time))
  0
  (none)
  )

(defbehavior tfl2-drop-plat-drop-all-children tfl2-drop-plat ()
  (dotimes (gp-0 (-> self child-count))
    (send-event (handle->process (-> self child-array data gp-0)) 'drop)
    (set! (-> self child-array data gp-0) (the-as handle #f))
    )
  #f
  )

(defbehavior tfl2-drop-plat-drop-children tfl2-drop-plat ((arg0 int))
  (cond
    ((= arg0 6)
     )
    (else
      (dotimes (s5-0 (-> self child-count))
        (let ((a0-3 (handle->process (-> self child-array data s5-0))))
          (when (and a0-3 (!= (-> (the-as tfl-drop-plat a0-3) color) 6) (= arg0 (-> (the-as tfl-drop-plat a0-3) color)))
            (send-event a0-3 'drop)
            (set! (-> self child-array data s5-0) (the-as handle #f))
            )
          )
        )
      )
    )
  0
  (none)
  )

(defstate tfl2-drop-plat-idle (tfl2-drop-plat)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go tfl2-drop-plat-active)
       )
      )
    )
  :code (behavior ()
    (tfl2-drop-plat-drop-all-children)
    (loop
      (suspend)
      )
    )
  )

(defstate tfl2-drop-plat-active (tfl2-drop-plat)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('player-stepped)
       (when (time-elapsed? (-> self drop-time) (seconds (res-lump-float (-> self entity) 'stepped-time :default 0.2))) ;; tfl note: added as a res-lump
         (set-time! (-> self drop-time))
         (tfl2-drop-plat-drop-children (the-as int (-> block param 0)))
         )
       )
      (('trigger)
       (go tfl2-drop-plat-idle)
       )
      )
    )
  :code (behavior ()
    (set-time! (-> self state-time))
    (tfl2-drop-plat-spawn-children)
    (loop
      (if (or (time-elapsed? (-> self state-time) (+ (-> self duration) (seconds 2)))
              (or (not *target*)
                  (< (-> self idle-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                  )
              (not (-> self child))
              )
          (go tfl2-drop-plat-idle)
          )
      (suspend)
      )
    )
  )

(defmethod init-from-entity! ((this tfl2-drop-plat) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (let ((v1-2 (res-lump-data arg0 'count pointer)))
    (when v1-2
      (set! (-> this x-count) (-> (the-as (pointer int32) v1-2) 0))
      (set! (-> this z-count) (-> (the-as (pointer int32) v1-2) 1))
      )
    )
  (set! (-> this child-count) (* (-> this x-count) (-> this z-count)))
  (set! (-> this child-color-array) (res-lump-data arg0 'plat-type (pointer int32))) ;; TFL note: changed from int8 to get lump to work
  (when (> (-> this child-count) 0)
    (set! (-> this child-array) (new 'process 'handle-inline-array (-> this child-count)))
    (dotimes (v1-9 (-> this child-count))
      (set! (-> this child-array data v1-9) (the-as handle #f))
      )
    )
  (set! (-> this x-spacing) (res-lump-float (-> this entity) 'x-spacing :default 16384.0)) ;; TFL note: added this as a res-lump
  (set! (-> this z-spacing) (res-lump-float (-> this entity) 'z-spacing :default 16384.0)) ;; TFL note: added this as a res-lump
  (set! (-> this idle-distance) (+ (res-lump-float (-> this entity) 'idle-distance :default 40960.0) (* 0.5 (the float (-> this z-count)) (-> this z-spacing)))) ;; TFL note: added this as a res-lump
  (set! (-> this duration) (the-as time-frame (the int (* (res-lump-float (-> this entity) 'drop-time :default 5.0) 300.0)))) ;; TFL note: added this as a res-lump
  (let ((f0-7 (res-lump-float arg0 'rotoffset)))
    (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-7)
    )
  (vector-x-quaternion! (-> this x-dir) (-> this root quat))
  (vector-z-quaternion! (-> this z-dir) (-> this root quat))
  (set! (-> this origin quad) (-> this root trans quad))
  (let ((f0-10 (* -0.5 (the float (+ (-> this x-count) -1)) (-> this x-spacing)))
        (f30-0 (* -0.5 (the float (+ (-> this z-count) -1)) (-> this z-spacing)))
        )
    (vector+*! (-> this origin) (-> this origin) (-> this x-dir) f0-10)
    (vector+*! (-> this origin) (-> this origin) (-> this z-dir) f30-0)
    )
  (go tfl2-drop-plat-idle)
  (none)
  )

(deftype tfl-firehose-button (basebutton)
  ()
  )

(deftype tfl-firehose-master (process-drawable)
  ((button-id                 int32)
   (hose-id                   int32)
   (plat-mask                 uint32)
   (hose-id-dir               int32)
   (wiggled?                  symbol)
   (timeout                   time-frame)
   (last-plat-activated-time  time-frame)
   (delay-til-wiggle          time-frame)
   (ticker                    ticky  :inline)
   )
  (:states
    tfl-firehose-master-activate
    tfl-firehose-master-idle
    )
  )

(deftype tfl-firehose (process-drawable)
  ((hose-id        int32)
   (root           collide-shape :override)
   (idle-distance  float)
   (activated      int32)
   (blast-pos      vector         :inline)
   )
  (:states
    tfl-firehose-active
    tfl-firehose-blast
    tfl-firehose-idle
    )
  )

(defstate tfl-firehose-master-idle (tfl-firehose-master)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (when (= (-> proc type) tfl-firehose-button)
         (set! (-> self button-id) (-> (the-as tfl-firehose-button proc) button-id))
         (logclear! (-> self mask) (process-mask actor-pause))
         (process-entity-status! self (entity-perm-status bit-3) #t)
         (go tfl-firehose-master-activate)
         )
       )
      )
    )
  :code (behavior ()
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

(defstate tfl-firehose-master-activate (tfl-firehose-master)
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self wiggled?) #f)
    (sleep (-> self ticker) (-> self timeout))
    (set! (-> self hose-id) -1)
    (send-to-all (-> self link) 'trigger)
    (set! (-> self hose-id) 0)
    (set! (-> (the-as tfl-firehose int32) activated) 0)
    (let ((gp-0 1))
      (if (< gp-0 0)
          (set! (-> self hose-id) 32)
          )
      (set! (-> self hose-id-dir) gp-0)
      )
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (process-entity-status! self (entity-perm-status bit-3) #f)
    )
  :trans (behavior ()
    (when (completed? (-> self ticker))
      (send-to-all (-> self link) 'untrigger)
      (go tfl-firehose-master-idle)
      )
    (when (reached-delay? (-> self ticker) (-> self delay-til-wiggle))
      (when (not (-> self wiggled?))
        (set! (-> self wiggled?) #t)
        (send-to-all (-> self link) 'bounce)
        )
      )
    (when (time-elapsed? (-> self last-plat-activated-time) (seconds 0.3))
      (set-time! (-> self last-plat-activated-time))
      (let ((v1-20 (-> self hose-id))
            (a0-5 (-> self hose-id-dir))
            (a1-3 (-> self plat-mask))
            )
        (loop
          (+! v1-20 a0-5)
          (cond
            ((<= v1-20 0)
             (set! (-> self hose-id) 0)
             (return #f)
             )
            ((>= v1-20 32)
             (set! (-> self hose-id) 32)
             (return #f)
             )
            (else
              (when (logtest? a1-3 (ash 1 v1-20))
                (set! (-> self hose-id) v1-20)
                (send-to-all (-> self link) 'trigger)
                (return #f)
                )
              )
            )
          )
        )
      )
    )
  :code (behavior ()
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

(defmethod init-from-entity! ((this tfl-firehose-master) (arg0 entity-actor))
  (set! (-> this button-id) -1)
  (set! (-> this hose-id) -1)
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (set! (-> this timeout)
        (the-as time-frame (the int (* 300.0 (res-lump-float (-> this entity) 'timeout :default 10.0))))
        )
  (set! (-> this delay-til-wiggle) (+ (-> this timeout) (seconds -0.4)))
  (set! (-> this link) (new 'process 'actor-link-info this))
  (set! (-> this plat-mask) (the-as uint (get-matching-actor-type-mask (-> this link) tfl-firehose)))
  (go tfl-firehose-master-idle)
  (none)
  )


(defskelgroup *citb-firehose-sg* citb-firehose citb-firehose-lod0-jg citb-firehose-idle-ja
              ((citb-firehose-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 15)
              )

(defstate tfl-firehose-idle (tfl-firehose)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('trigger)
        (set! (-> self activated) 0)
        )
        (('untrigger)
        (set! (-> self activated) 1)
        )
      )
    )
  :code (behavior ()
    (loop
      (if (= 1 (-> self activated))
        (go tfl-firehose-active)
        )
      (suspend)
      )
    )
  :post ja-post
  )

(defstate tfl-firehose-active (tfl-firehose)
  :trans (behavior ()
    (if (= 1 (-> self activated))
      (go tfl-firehose-blast)
    )
    )
  :code (behavior ()
    (loop
      (suspend)
      )
    )
  :post ja-post
  )

(defbehavior tfl-firehose-blast-particles tfl-firehose ()
  (let ((gp-0 (new 'stack-no-clear 'quaternion)))
    (quaternion-identity! gp-0)
    (quaternion-rotate-local-x! gp-0 gp-0 -16384.0)
    (dotimes (s5-0 16)
      (quaternion-rotate-local-z! gp-0 gp-0 2048.0)
      (quaternion-copy! *particle-quat* gp-0)
      (launch-particles :system *sp-particle-system-3d* (-> *part-id-table* 3801) (-> self blast-pos))
      )
    )
  (spawn (-> self part) (-> self blast-pos))
  )

(defstate tfl-firehose-blast (tfl-firehose)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch)
       (send-event
         proc
         'attack-or-shove
         (-> block param 0)
         (static-attack-info ((mode 'burn) (shove-back (meters 6)) (shove-up (meters 3))))
         )
       )
       (('trigger)
        (set! (-> self activated) 0)
        )
        (('untrigger)
        (set! (-> self activated) 1)
        )
      )
    )
  :code (behavior ()
    (ja-no-eval :group! citb-firehose-start-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 0.75))
      )
    (ja-channel-push! 1 (seconds 0.1))
    (restore-collide-with-as (-> self root))
    (sound-play "eco-torch" :position (the-as symbol (-> self blast-pos)))
    (until (= 0 (-> self activated)) ;; TFL note: changed dotimes (gp-1 5) to condition for the button
      (ja-no-eval :group! citb-firehose-loopflame-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (set! (-> self blast-pos quad) (-> self node-list data 5 bone transform vector 3 quad))
        (tfl-firehose-blast-particles)
        (suspend)
        (ja :num! (seek! max 0.5))
        )
      )
    (clear-collide-with-as (-> self root))
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! citb-firehose-end-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 0.75))
      )
    (go tfl-firehose-idle)
    )
  :post transform-post
  )

(defmethod init-from-entity! ((this tfl-firehose) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 -61440.0 0.0 36864.0)
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> s2-0 local-sphere) 0.0 -49152.0 0.0 12288.0)
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> s2-1 local-sphere) 0.0 -61440.0 0.0 12288.0)
        (append-prim s3-0 s2-1)
        )
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> s2-2 local-sphere) 0.0 -73728.0 0.0 12288.0)
        (append-prim s3-0 s2-2)
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *citb-firehose-sg* '())
  (set! (-> this activated) 1)
  (set! (-> this idle-distance) (res-lump-float (-> this entity) 'idle-distance :default 286720.0))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1001) this))
  (clear-collide-with-as (-> this root))
  (go tfl-firehose-idle)
  (none)
  )

(deftype cavecrusher (process-drawable)
  ((root  collide-shape :override)
   )
  (:states
    cavecrusher-idle
    )
  )


(defskelgroup *cavecrusher-sg* cavecrusher cavecrusher-lod0-jg -1
              ((cavecrusher-lod0-mg (meters 20)) (cavecrusher-lod1-mg (meters 40)) (cavecrusher-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(defstate cavecrusher-idle (cavecrusher)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (when (= (-> proc type) target)
         (if ((method-of-type touching-shapes-entry prims-touching-action?)
              (the-as touching-shapes-entry (-> block param 0))
              (-> *target* control)
              (collide-action solid)
              (collide-action)
              )
             (target-attack-up *target* 'attack-or-shove 'deadlyup)
             )
         )
       )
      )
    )
  :code (behavior ()
    (loop
      (ja-no-eval :group! cavecrusher-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (update! (-> self sound))
        (suspend)
        (ja :num! (seek!))
        )
      )
    )
  :post ja-post
  )

(defmethod init-from-entity! ((this cavecrusher) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 11468.8)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *cavecrusher-sg* '())
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "crush-click" :fo-max 30) (-> this root trans))
        )
  (ja-channel-push! 1 0)
  (let ((s5-1 (-> this skel root-channel 0)))
    (joint-control-channel-group-eval!
      s5-1
      (the-as art-joint-anim (-> this draw art-group data 4))
      num-func-identity
      )
    (set! (-> s5-1 frame-num) 0.0)
    )
  (ja-post)
  (update-transforms! (-> this root))
  (go cavecrusher-idle)
  (none)
  )

(deftype caveelevator (process-drawable)
  ((root                     collide-shape-moving :override)
   (elev-mode                uint64)
   (elev-type                int32)
   (prev-frame-num           float)
   (last-update-bounce-time  time-frame)
   (orig-trans               vector                :inline)
   (sync                     sync-info             :inline)
   (smush                    smush-control         :inline)
   (anim                     int32                 2)
   (wheel-ry-mat             matrix                :inline :offset 272)
   )
  (:methods
    (caveelevator-method-20 (_type_) none)
    (caveelevator-method-21 (_type_) float)
    )
  (:states
    caveelevator-cycle-active
    caveelevator-one-way-idle-end
    caveelevator-one-way-idle-start
    caveelevator-one-way-travel-to-end
    caveelevator-one-way-travel-to-start
    )
  )


(defskelgroup *caveelevator-sg* caveelevator caveelevator-lod0-jg -1
              ((caveelevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4.25)
              )

(defmethod caveelevator-method-20 ((this caveelevator))
  (let ((v1-1 (current-time)))
    (when (!= v1-1 (-> this last-update-bounce-time))
      (set! (-> this last-update-bounce-time) v1-1)
      (when (!= (-> this smush amp) 0.0)
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (set! (-> s5-0 quad) (-> this orig-trans quad))
          (+! (-> s5-0 y) (* 819.2 (update! (-> this smush))))
          (move-to-point! (-> this root) s5-0)
          )
        )
      )
    )
  (none)
  )

(defmethod caveelevator-method-21 ((this caveelevator))
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (gp-0 (-> this draw bounds))
        )
    (vector<-cspace! s5-0 (-> this node-list data 3))
    (vector-! gp-0 s5-0 (-> this root trans))
    (set! (-> gp-0 w) 17408.0)
    )
  )

(defstate caveelevator-cycle-active (caveelevator)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (activate! (-> self smush) -1.0 60 150 1.0 1.0)
       )
      )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    )
  :code (behavior ()
    (loop
      (let ((f30-1 (* (get-current-phase (-> self sync)) (the float (ja-num-frames 0)))))
        (if (< (-> self prev-frame-num) f30-1)
            (ja :num! (seek! f30-1 10000.0))
            ;; (ja :num! (seek! f30-1 0.5))
            (ja :num-func num-func-identity :frame-num f30-1 )
            )
        (set! (-> self prev-frame-num) f30-1)
        )
      (suspend)
      )
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    )
  )

(defstate caveelevator-one-way-idle-start (caveelevator)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (activate! (-> self smush) -1.0 60 150 1.0 1.0)
       (go caveelevator-one-way-travel-to-end)
       )
      (('attack 'touch)
       (if (and (= (-> proc type) target) (>= 8192.0 (vector-vector-xz-distance (target-pos 0) (-> self root trans))))
           (go caveelevator-one-way-travel-to-end)
           )
       )
      )
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    )
  :code (behavior ()
    (ja :group! (-> (the-as art-joint-anim (+ (* (-> self anim 0) 4) (the-as int (-> self draw art-group))))
                   master-art-group-name
                   )
        :num! min
        )
    (loop
      (suspend)
      )
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    )
  )

(defstate caveelevator-one-way-travel-to-end (caveelevator)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (activate! (-> self smush) -1.0 60 150 1.0 1.0)
       )
      )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    )
  :code (behavior ()
    (ja :group! (-> self draw art-group data (-> self anim 0)) :num! min)
    (ja-no-eval :num! (seek!))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go caveelevator-one-way-idle-end)
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    )
  )

(defstate caveelevator-one-way-idle-end (caveelevator)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (activate! (-> self smush) -1.0 60 150 1.0 1.0)
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (cond
      ((zero? (-> self root riders num-riders))
       (if (time-elapsed? (-> self state-time) (seconds 3))
           (go caveelevator-one-way-travel-to-start)
           )
       )
      (else
        (set-time! (-> self state-time))
        )
      )
    (rider-trans)
    (caveelevator-method-20 self)
    )
  :code (behavior ()
    (ja :group! (-> self draw art-group data (-> self anim 0)) :num! max)
    (loop
      (suspend)
      )
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    )
  )

(defstate caveelevator-one-way-travel-to-start (caveelevator)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (activate! (-> self smush) -1.0 60 150 1.0 1.0)
       )
      )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    )
  :code (behavior ()
    (ja :group! (-> self draw art-group data (-> self anim 1)) :num! min)
    (ja-no-eval :num! (seek!))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go caveelevator-one-way-idle-start)
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    )
  )

(defun caveelevator-joint-callback ((arg0 caveelevator))
  (let* ((gp-0 arg0)
         (f1-1 (- (-> arg0 node-list data 3 bone transform vector 3 y) (-> gp-0 orig-trans y)))
         (f30-0 (* 5.0929585 (- f1-1 (* (the float (the int (/ f1-1 12867.963))) 12867.963))))
         (s3-0 (-> arg0 node-list data 5 bone transform))
         (s4-0 (-> arg0 node-list data 4 bone transform))
         (s5-0 (new 'stack-no-clear 'vector))
         )
    (set! (-> s5-0 quad) (-> s3-0 vector 3 quad))
    (matrix-rotate-x! s3-0 f30-0)
    (matrix*! s3-0 s3-0 (-> gp-0 wheel-ry-mat))
    (set! (-> s3-0 vector 3 quad) (-> s5-0 quad))
    (set! (-> s5-0 quad) (-> s4-0 vector 3 quad))
    (matrix-rotate-x! s4-0 (- f30-0))
    (matrix*! s4-0 s4-0 (-> gp-0 wheel-ry-mat))
    (set! (-> s4-0 vector 3 quad) (-> s5-0 quad))
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this caveelevator) (arg0 entity-actor))
  (local-vars (v1-43 int) (sv-16 res-tag))
  (set! (-> this prev-frame-num) 10000.0)
  (set! (-> this last-update-bounce-time) 0)
  (logior! (-> this mask) (process-mask platform))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky rider-plat))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 17408.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *caveelevator-sg* '())
  (logior! (-> this skel status) (janim-status inited))
  (set! (-> this skel postbind-function) caveelevator-joint-callback)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-28 (res-lump-data arg0 'trans-offset (pointer float) :tag-ptr (& sv-16))))
    (when v1-28
      (+! (-> this root trans x) (-> v1-28 0))
      (+! (-> this root trans y) (-> v1-28 1))
      (+! (-> this root trans z) (-> v1-28 2))
      )
    )
  (set! (-> this orig-trans quad) (-> this root trans quad))
  (let ((f0-13 (res-lump-float (-> this entity) 'rotoffset)))
    (if (!= f0-13 0.0)
        (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-13)
        )
    )
  (let ((f0-14 (quaternion-y-angle (-> this root quat))))
    (matrix-rotate-y! (-> this wheel-ry-mat) f0-14)
    )
  (set-zero! (-> this smush))
  (let ((s5-1 (res-lump-value arg0 'mode uint32)))
    0
    (set! (-> this elev-type) (the-as int s5-1))
    (let ((v1-42 s5-1))
      (cond
        ((zero? v1-42)
         (set! v1-43 0)
         (set! (-> this anim 0) 2)
         )
        ((= (the-as uint v1-42) 1)
         (set! v1-43 1)
         (set! (-> this anim 0) 3)
         (set! (-> this anim 1) 4)
         )
        ((= (the-as uint v1-42) 2)
         (set! v1-43 0)
         (set! (-> this anim 0) 5)
         )
        (else
          (set! v1-43 0)
          (set! (-> this anim 0) 2)
          (set! (-> this elev-type) (the-as int s5-1))
          )
        )
      )
    (set! (-> this elev-mode) (the-as uint v1-43))
    (ja-channel-set! 1)
    (let ((s4-1 (-> this skel root-channel 0)))
      (joint-control-channel-group-eval!
        s4-1
        (the-as art-joint-anim (-> this draw art-group data (-> this anim 0)))
        num-func-identity
        )
      (set! (-> s4-1 frame-num) 0.0)
      )
    )
  (transform-post)
  (let ((v1-55 (-> this elev-mode)))
    (cond
      ((zero? v1-55)
       (load-params! (-> this sync) this (the-as uint 3000) 0.0 0.15 0.15)
       (go caveelevator-cycle-active)
       )
      ((= v1-55 1)
       (go caveelevator-one-way-idle-start)
       )
      )
    )
  (none)
  )

(deftype mistycam (process-hidden)
  ()
  )


(defskelgroup *mistycam-sg* mistycam mistycam-lod0-jg mistycam-anim-ja
              ((mistycam-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 20)
              )

(defun mistycam-spawn ()
  (with-pp
    (let ((gp-0 (entity-actor-lookup (-> pp entity) 'alt-actor 0)))
      (when gp-0
        (let* ((gp-1
                 (ppointer->handle (process-spawn
                                     pov-camera
                                     (-> gp-0 extra trans)
                                     *mistycam-sg*
                                     (new 'static 'spool-anim :name "mistycam-cannon" :index 5 :parts 1 :command-list '())
                                     0
                                     #f
                                     '()
                                     :to pp
                                     )
                                   )
                 )
               (s5-2 (ppointer->handle
                       (process-spawn fuel-cell :init fuel-cell-init-as-clone gp-1 (-> pp entity extra perm task) :to pp)
                       )
                     )
               )
          (let ((v1-13 (handle->process gp-1)))
            (if v1-13
                (set! (-> (the-as pov-camera v1-13) notify-handle) (the-as handle s5-2))
                )
            )
          (while (handle->process gp-1)
            (suspend)
            )
          (send-event (handle->process s5-2) 'stop-cloning)
          )
        )
      )
    0
    (none)
    )
  )

(deftype mines-battlecontroller (battlecontroller)
  ()
  )


(defstate battlecontroller-play-intro-camera (mines-battlecontroller)
  :virtual #t
  :code (behavior ()
    (let ((gp-1 (ppointer->handle
                  (process-spawn pov-camera (-> self root trans) *mistycam-sg* "lurkerattack" 0 #f '() :to self)
                  )
                )
          )
      (while (handle->process (the-as handle gp-1))
        (suspend)
        )
      )
    (go-virtual battlecontroller-active)
    )
  )

(defmethod battlecontroller-method-27 ((this mines-battlecontroller))
  (call-parent-method this)
  (set! (-> this misty-ambush-collision-hack) #t)
  0
  (none)
  )

(defun-debug misty-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) -711702.3)
    (set! (-> a0-0 y) 268833.34)
    (set! (-> a0-0 z) 4193524.2)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.6991)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) -0.7149)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) 0.3474)
    (set! (-> a1-0 vector 1 y) 0.8739)
    (set! (-> a1-0 vector 1 z) -0.3398)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) 0.6248)
    (set! (-> a1-0 vector 2 y) -0.486)
    (set! (-> a1-0 vector 2 z) -0.611)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 11650.845)
  (clear *camera-old-level*)
  (format *camera-old-level* "misty")
  (set! *camera-old-cpu* 6867)
  (set! *camera-old-vu* #x4b0f)
  (set! *camera-old-tfrag-bytes* #x1ec490)
  (clear *camera-old-stat-string-tfrag*)
  (clear *camera-old-stat-string-tfrag-near*)
  (clear *camera-old-stat-string-total*)
  (let ((v0-7 #t))
    (set! *display-camera-old-stats* v0-7)
    v0-7
    )
  )