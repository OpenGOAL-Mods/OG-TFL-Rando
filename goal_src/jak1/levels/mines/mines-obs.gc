;;-*-Lisp-*-
(in-package goal)

(defpartgroup group-misty-bone-01
  :id 192
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 24)
  :parts ((sp-item 914 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 915 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 916 :period (seconds 2.6) :length (seconds 0.215))
    (sp-item 917 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 918 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 919 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 920 :period (seconds 2.6) :length (seconds 0.107) :offset 65056)
    (sp-item 921 :period (seconds 2.6) :length (seconds 0.107) :offset 64996)
    )
  )

(defpart 921
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 187))
    )
  )

(defpart 920
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters 2.5))
    (:y (meters 1) (meters 1))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.006666667) (meters 0.013333334))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters 0.000033333334))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 80) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 187))
    )
  )

(defpart 919
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 187))
    )
  )

(defpart 918
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 0.05) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 64.0 32.0)
    (:vel-x (meters -0.026666667) (meters 0.013333334))
    (:vel-y (meters -0.013333334) (meters 0.053333335))
    (:vel-z (meters -0.033333335) (meters 0.06666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:accel-y (meters -0.0016666667))
    (:friction 0.996)
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:next-time (seconds 0.3))
    (:next-launcher 922)
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 187))
    )
  )

(defpart 922
  :init-specs ((:fade-a -1.0666667))
  )

(defpart 917
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:y (meters -1) (meters 1.5))
    (:z (meters -5) (meters 10))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.026666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 4) (meters 16))
    (:rotate-y (degrees 187))
    )
  )

(defpart 914
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:y (meters 1) (meters 1))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.006666667) (meters 0.013333334))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters 0.000033333334))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 80) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 140))
    )
  )

(defpart 915
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:y (meters 1) (meters 1))
    (:scale-x (meters 0.05) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 64.0 32.0)
    (:vel-y (meters 0.04) (meters 0.026666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:accel-y (meters -0.0016666667))
    (:friction 0.996)
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:next-time (seconds 0.3))
    (:next-launcher 923)
    (:conerot-x (degrees 70) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 140))
    )
  )

(defpart 923
  :init-specs ((:fade-a -3.2))
  )

(defpart 916
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 2.0)
    (:x (meters -3.5) (meters 4.5))
    (:y (meters 1) (meters 12))
    (:z (meters -3) (meters 6))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 8.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.017777778)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:rotate-y (degrees 187))
    )
  )

(defpartgroup group-misty-bone-03
  :id 193
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 24)
  :parts ((sp-item 914 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 915 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 924 :period (seconds 2.6) :length (seconds 0.215))
    (sp-item 925 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 926 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 927 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 928 :period (seconds 2.6) :length (seconds 0.107) :offset 65056)
    (sp-item 929 :period (seconds 2.6) :length (seconds 0.107) :offset 64996)
    )
  )

(defpart 929
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpart 928
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters 2.5))
    (:y (meters 1) (meters 1))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.006666667) (meters 0.013333334))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters 0.000033333334))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 80) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpart 927
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpart 926
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 0.05) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 64.0 32.0)
    (:vel-x (meters -0.026666667) (meters 0.013333334))
    (:vel-y (meters -0.013333334) (meters 0.053333335))
    (:vel-z (meters -0.033333335) (meters 0.06666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:accel-y (meters -0.0016666667))
    (:friction 0.996)
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:next-time (seconds 0.3))
    (:next-launcher 922)
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpart 925
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:y (meters -1) (meters 1.5))
    (:z (meters -5) (meters 10))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.026666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -80))
    (:conerot-radius (meters 4) (meters 16))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpart 924
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 2.0)
    (:x (meters -3.5) (meters 4.5))
    (:y (meters 1) (meters 12))
    (:z (meters -3) (meters 6))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 8.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.017777778)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:rotate-y (degrees 249.99998))
    )
  )

(defpartgroup group-misty-bone-02
  :id 194
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 24)
  :parts ((sp-item 914 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 915 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 930 :period (seconds 2.6) :length (seconds 0.215))
    (sp-item 931 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 932 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 933 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 934 :period (seconds 2.6) :length (seconds 0.107) :offset 65056)
    (sp-item 935 :period (seconds 2.6) :length (seconds 0.107) :offset 64996)
    )
  )

(defpart 935
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 114))
    )
  )

(defpart 934
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters 2.5))
    (:y (meters 1) (meters 1))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.006666667) (meters 0.013333334))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters 0.000033333334))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 80) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 114))
    )
  )

(defpart 933
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 114))
    )
  )

(defpart 932
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 0.05) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 64.0 32.0)
    (:vel-x (meters -0.026666667) (meters 0.013333334))
    (:vel-y (meters -0.013333334) (meters 0.053333335))
    (:vel-z (meters -0.033333335) (meters 0.06666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:accel-y (meters -0.0016666667))
    (:friction 0.996)
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:next-time (seconds 0.3))
    (:next-launcher 922)
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 114))
    )
  )

(defpart 931
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:y (meters -1) (meters 1.5))
    (:z (meters -5) (meters 10))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.026666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -90))
    (:conerot-radius (meters 4) (meters 16))
    (:rotate-y (degrees 114))
    )
  )

(defpart 930
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 2.0)
    (:x (meters -3.5) (meters 4.5))
    (:y (meters 1) (meters 12))
    (:z (meters -3) (meters 6))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 8.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.017777778)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:rotate-y (degrees 114))
    )
  )

(defpartgroup group-misty-bone-07
  :id 195
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 24)
  :parts ((sp-item 914 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 915 :period (seconds 2.6) :length (seconds 0.05))
    (sp-item 936 :period (seconds 2.6) :length (seconds 0.215))
    (sp-item 937 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 938 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 939 :period (seconds 2.6) :length (seconds 0.107) :offset 65131)
    (sp-item 940 :period (seconds 2.6) :length (seconds 0.107) :offset 65056)
    (sp-item 941 :period (seconds 2.6) :length (seconds 0.107) :offset 64966)
    )
  )

(defpart 941
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 14.000005))
    )
  )

(defpart 940
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters 2.5))
    (:y (meters 1) (meters 1))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.006666667) (meters 0.013333334))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters 0.000033333334))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-x (degrees 80) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2))
    (:rotate-y (degrees 14.000005))
    )
  )

(defpart 939
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 3.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 16.0)
    (:vel-y (meters -0.01) (meters 0.04))
    (:vel-z (meters -0.023333333) (meters 0.046666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 14.000005))
    )
  )

(defpart 938
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:x (meters -0.5) (meters 1.5))
    (:y (meters 1.5) (meters 0.5))
    (:z (meters -2.5) (meters 5))
    (:scale-x (meters 0.05) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 64.0 32.0)
    (:vel-x (meters -0.026666667) (meters 0.013333334))
    (:vel-y (meters -0.013333334) (meters 0.053333335))
    (:vel-z (meters -0.033333335) (meters 0.06666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:accel-y (meters -0.0016666667))
    (:friction 0.996)
    (:timer (seconds 1))
    (:flags (bit2 bit12))
    (:next-time (seconds 0.3))
    (:next-launcher 922)
    (:conerot-z (degrees -94))
    (:conerot-radius (meters 18))
    (:rotate-y (degrees 14.000005))
    )
  )

(defpart 937
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 8.0)
    (:y (meters -1) (meters 1.5))
    (:z (meters -5) (meters 10))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 16.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.026666667)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:conerot-z (degrees -90))
    (:conerot-radius (meters 4) (meters 16))
    (:rotate-y (degrees 14.000005))
    )
  )

(defpart 936
  :init-specs ((:texture (new 'static 'texture-id :index #x19 :page #x2))
    (:num 2.0)
    (:x (meters -3.5) (meters 4.5))
    (:y (meters 1) (meters 12))
    (:z (meters -3) (meters 6))
    (:scale-x (meters 2) (meters 3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 100.0 32.0)
    (:b 90.0 32.0)
    (:a 8.0 8.0)
    (:vel-y (meters -0.0016666667))
    (:rotvel-z (degrees -0.15) 1 (degrees 0.3))
    (:fade-a -0.017777778)
    (:accel-y (meters -0.0001))
    (:timer (seconds 3))
    (:flags (bit2 bit12))
    (:rotate-y (degrees 14.000005))
    )
  )

(deftype mis-bone-bridge (process-drawable)
  ((root              collide-shape-moving :override)
   (particle-group    sparticle-launch-group)
   (player-attack-id  int32)
   (fall-anim-index   int32)
   (hit-points        int8)
   )
  (:states
    mis-bone-bridge-bump
    (mis-bone-bridge-fall symbol)
    mis-bone-bridge-hit
    mis-bone-bridge-idle
    )
  )


(defskelgroup *mis-bone-bridge-sg* mis-bone-bridge mis-bone-bridge-lod0-jg mis-bone-bridge-idle-ja
              ((mis-bone-bridge-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 15 0 40)
              )

(defbehavior mis-bone-bridge-event-handler mis-bone-bridge ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (let ((s5-0 (-> arg3 param 2))
           (gp-0 (vector-x-quaternion! (new-stack-vector0) (-> self root quat)))
           (a0-4 (vector-z-quaternion! (new-stack-vector0) (-> self root quat)))
           (v1-4 (vector-! (new-stack-vector0) (-> *target* control trans) (-> self root trans)))
           )
       0.0
       0.0
       (when (!= s5-0 (-> self player-attack-id))
         (set! (-> self player-attack-id) (the-as int s5-0))
         (let ((f0-3 (vector-dot gp-0 v1-4))
               (f1-1 (vector-dot a0-4 v1-4))
               )
           (cond
             ((and (< 0.0 f1-1) (< (fabs (* 0.5 f0-3)) f1-1))
              (if (send-event *target* 'query 'powerup (pickup-type eco-red))
                  (go mis-bone-bridge-fall #f)
                  (go mis-bone-bridge-hit)
                  )
              )
             (else
               (go mis-bone-bridge-bump)
               #f
               )
             )
           )
         )
       )
     )
    )
  )

(defstate mis-bone-bridge-idle (mis-bone-bridge)
  :event mis-bone-bridge-event-handler
  :code (behavior ()
    (ja :num-func num-func-identity :frame-num 0.0)
    (loop
      (if (and *target* (>= 32768.0 (vector-vector-distance (-> self root trans) (-> *target* control trans))))
          (level-hint-spawn
            (text-id misty-bone-bridge-hint)
            "sksp0435"
            (the-as entity #f)
            *entity-pool*
            (game-task none)
            )
          )
      (suspend)
      )
    )
  :post transform-post
  )

(defstate mis-bone-bridge-bump (mis-bone-bridge)
  :event mis-bone-bridge-event-handler
  :trans rider-trans
  :code (behavior ()
    (ja-no-eval :group! mis-bone-bridge-bumped-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go mis-bone-bridge-idle)
    )
  :post rider-post
  )

(defstate mis-bone-bridge-hit (mis-bone-bridge)
  :event mis-bone-bridge-event-handler
  :trans rider-trans
  :code (behavior ()
    (+! (-> self hit-points) -1)
    (if (zero? (-> self hit-points))
        (go mis-bone-bridge-fall #f)
        )
    (ja-no-eval :group! mis-bone-bridge-kicked-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go mis-bone-bridge-idle)
    )
  :post rider-post
  )

(defstate mis-bone-bridge-fall (mis-bone-bridge)
  :trans rider-trans
  :code (behavior ((arg0 symbol))
    (process-entity-status! self (entity-perm-status complete) #t)
    (when (not arg0)
      (process-spawn
        part-tracker
        :init part-tracker-init
        (-> self particle-group)
        -1
        #f
        #f
        #f
        (-> self root trans)
        :to *entity-pool*
        )
      (ja-no-eval :group! (-> self draw art-group data (-> self fall-anim-index)) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (ja :group! (-> self draw art-group data (-> self fall-anim-index))
        :num! (identity (the float (+ (-> (ja-group) data 0 length) -1)))
        )
    (loop
      (suspend)
      )
    )
  :post rider-post
  )

(defmethod init-from-entity! ((this mis-bone-bridge) (arg0 entity-actor))
  (logior! (-> this mask) (process-mask platform))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-others))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid attackable attackable-unused))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 (* 98304.0 (res-lump-value arg0 'scale float)) )
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core action) (collide-action solid))
        (set! (-> s2-0 prim-core offense) (collide-offense indestructible))
        (set! (-> s2-0 transform-index) 0)
        (set-vector! (-> s2-0 local-sphere) 0.0 0.0 0.0 (* 9011.2 (res-lump-value arg0 'scale float)))
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind ground-object))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core action) (collide-action solid))
        (set! (-> s2-1 prim-core offense) (collide-offense indestructible))
        (set! (-> s2-1 transform-index) 4)
        (set-vector! (-> s2-1 local-sphere) 0.0 49152.0 0.0 (* 49152.0 (res-lump-value arg0 'scale float)))
        (append-prim s3-0 s2-1)
        )
      )
    (set! (-> s4-0 nav-radius) (* (* 0.75 (-> s4-0 root-prim local-sphere w)) (res-lump-value arg0 'scale float)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *mis-bone-bridge-sg* '())
  (let ((v1-40 (res-lump-value arg0 'animation-select uint128)))
    (cond
      ((= (the-as uint v1-40) 1)
       (set! (-> this fall-anim-index) 2)
       (set! (-> this particle-group) (-> *part-group-id-table* 192))
       )
      ((= (the-as uint v1-40) 2)
       (set! (-> this fall-anim-index) 3)
       (set! (-> this particle-group) (-> *part-group-id-table* 194))
       )
      ((= (the-as uint v1-40) 3)
       (set! (-> this fall-anim-index) 2)
       (set! (-> this particle-group) (-> *part-group-id-table* 193))
       )
      ((= (the-as uint v1-40) 7)
       (set! (-> this fall-anim-index) 4)
       (set! (-> this particle-group) (-> *part-group-id-table* 195))
       )
      (else
        (set! (-> this fall-anim-index) 2)
        (set! (-> this particle-group) (-> *part-group-id-table* 192))
        )
      )
    )
  (set! (-> this hit-points) 3)
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status complete)))
      (go mis-bone-bridge-fall #t)
      (go mis-bone-bridge-idle)
      )
  (none)
  )

(define *bone-platform-constants* (new 'static 'rigid-body-platform-constants
                                    :drag-factor 2.0
                                    :buoyancy-factor 5.0
                                    :max-buoyancy-depth (meters 2)
                                    :gravity-factor 1.0
                                    :gravity (meters 80)
                                    :player-weight (meters 15)
                                    :player-bonk-factor 1.0
                                    :player-dive-factor 1.0
                                    :player-force-distance (meters 1000)
                                    :player-force-clamp (meters 1000000)
                                    :player-force-timeout (seconds 0.1)
                                    :explosion-force (meters 1000)
                                    :linear-damping 1.0
                                    :angular-damping 1.0
                                    :control-point-count 5
                                    :mass 2.0
                                    :inertial-tensor-x (meters 3)
                                    :inertial-tensor-y (meters 2)
                                    :inertial-tensor-z (meters 3)
                                    :cm-joint-y (meters -3)
                                    :idle-distance (meters 50)
                                    :platform #t
                                    :sound-name "mud-plat"
                                    )
        )

(deftype bone-platform (rigid-body-platform)
  ((anchor-point  vector  :inline)
   )
  )


(defskelgroup *mis-bone-platform-sg* mis-bone-platform mis-bone-platform-lod0-jg mis-bone-platform-idle-ja
              ((mis-bone-platform-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defmethod rigid-body-platform-method-27 ((this bone-platform) (arg0 vector))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (vector-! gp-0 arg0 (-> this rbody position))
    (set! (-> gp-0 y) 0.0)
    (let* ((f0-1 (vector-length gp-0))
           (f1-1 (* 20.0 (fmax 0.0 (fmin 4096.0 (+ -819.2 f0-1)))))
           )
      (when (< 0.0 f1-1)
        (vector-float*! gp-0 gp-0 (/ f1-1 f0-1))
        (rigid-body-method-15 (-> this rbody) gp-0)
        )
      )
    )
  0
  (none)
  )

(defmethod rigid-body-platform-method-23 ((this bone-platform) (arg0 float))
  (call-parent-method this arg0)
  (rigid-body-platform-method-27 this (-> this anchor-point))
  0
  (none)
  )

(defstate rigid-body-platform-idle (bone-platform)
  :virtual #t
  :enter (behavior ()
    (ja-channel-set! 0)
    )
  :code (behavior ()
    (loop
      (suspend)
      )
    )
  :post ja-post
  )

(defstate rigid-body-platform-float (bone-platform)
  :virtual #t
  :event rigid-body-platform-event-handler
  :trans (behavior ()
    (-> self entity extra trans y)
    (cond
      ((or (not *target*) (< (-> self info idle-distance)
                             (vector-vector-distance (-> self root-overlay trans) (-> *target* control trans))
                             )
           )
       (let ((f30-1 -4096.0))
         (seek! (-> self float-height-offset) f30-1 (* 2048.0 (seconds-per-frame)))
         (if (= (-> self float-height-offset) f30-1)
             (go-virtual rigid-body-platform-idle)
             )
         )
       )
      (else
        (seek! (-> self float-height-offset) 4096.0 (* 2048.0 (seconds-per-frame)))
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! mis-bone-platform-idle-ja)
    (ja :num-func num-func-identity :frame-num 0.0)
    (loop
      (suspend)
      )
    )
  :post rigid-body-platform-post
  )

(defmethod rigid-body-platform-method-30 ((this bone-platform))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root-overlay) s5-0)
    )
  0
  (none)
  )

(defmethod rigid-body-platform-method-31 ((this bone-platform))
  (initialize-skeleton this *mis-bone-platform-sg* '())
  (rigid-body-platform-method-29 this *bone-platform-constants*)
  (set! (-> this float-height-offset) -4096.0)
  (if (name= (-> this name) "bone-platform-5")
      (set-vector! (-> this root-overlay scale) 0.8 1.0 0.8 1.0)
      )
  (let ((s5-0 (-> this info control-point-count)))
    (dotimes (s4-0 s5-0)
      (let ((s3-0 (-> this control-point-array data s4-0)))
        (let ((f30-0 (* 65536.0 (/ (the float s4-0) (the float s5-0)))))
          (set! (-> s3-0 local-pos x) (* 12288.0 (sin f30-0)))
          (set! (-> s3-0 local-pos y) -12288.0)
          (set! (-> s3-0 local-pos z) (* 12288.0 (cos f30-0)))
          )
        (set! (-> s3-0 local-pos w) 1.0)
        )
      )
    )
  (set! (-> this anchor-point quad) (-> this root-overlay trans quad))
  0
  (none)
  )

(defskelgroup *citb-button-sg* citb-button citb-button-lod0-jg citb-button-idle-ja
              ((citb-button-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(deftype citb-button (basebutton)
  ()
  )


(defmethod basebutton-method-27 ((this citb-button))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0)
    )
  (the-as collide-shape-moving 0)
  )

(defmethod basebutton-method-26 ((this citb-button))
  (initialize-skeleton this *citb-button-sg* '())
  (logior! (-> this skel status) (janim-status inited))
  (ja-channel-set! 1)
  (cond
    ((-> this down?)
     (let ((s5-0 (-> this skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-0
         (the-as art-joint-anim (-> this draw art-group data 2))
         num-func-identity
         )
       (set! (-> s5-0 frame-num)
             (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 2)) data 0 length) -1))
             )
       )
     )
    (else
      (let ((s5-1 (-> this skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-1
          (the-as art-joint-anim (-> this draw art-group data 2))
          num-func-identity
          )
        (set! (-> s5-1 frame-num) 0.0)
        )
      )
    )
  (set! (-> this anim-speed) 2.0)
  (set! (-> this timeout) 1.0)
  (update-transforms! (-> this root))
  (ja-post)
  (none)
  )

(defskelgroup *citb-drop-plat-sg* citb-drop-plat citb-drop-plat-lod0-jg citb-drop-plat-idle-ja
              ((citb-drop-plat-lod0-mg (meters 20)) (citb-drop-plat-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *citb-drop-plat-red-sg* citb-drop-plat citb-drop-plat-red-lod0-jg citb-drop-plat-red-idle-ja
              ((citb-drop-plat-red-lod0-mg (meters 20)) (citb-drop-plat-red-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *citb-drop-plat-green-sg* citb-drop-plat citb-drop-plat-green-lod0-jg citb-drop-plat-green-idle-ja
              ((citb-drop-plat-green-lod0-mg (meters 20)) (citb-drop-plat-green-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *citb-drop-plat-blue-sg* citb-drop-plat citb-drop-plat-blue-lod0-jg citb-drop-plat-blue-idle-ja
              ((citb-drop-plat-blue-lod0-mg (meters 20)) (citb-drop-plat-blue-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defskelgroup *citb-drop-plat-yellow-sg* citb-drop-plat citb-drop-plat-yellow-lod0-jg citb-drop-plat-yellow-idle-ja
              ((citb-drop-plat-yellow-lod0-mg (meters 20)) (citb-drop-plat-yellow-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(deftype tfl-drop-plat (process-drawable)
  ((root        collide-shape-moving :override)
   (spin-axis   vector                :inline)
   (spin-angle  float)
   (spin-speed  float)
   (interp      float)
   (duration    time-frame)
   (delay       time-frame)
   (color       int32) ;; TFL note: changed from int8 to get lump to work
   )
  (:methods
    (tfl-drop-plat-method-20 (_type_) none)
    (tfl-drop-plat-method-21 (_type_) none)
    )
  (:states
    tfl-drop-plat-die
    tfl-drop-plat-drop
    tfl-drop-plat-idle
    (tfl-drop-plat-rise draw-control)
    tfl-drop-plat-spawn
    )
  )


(defstate tfl-drop-plat-idle (tfl-drop-plat)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('drop)
       (logclear! (-> self mask) (process-mask actor-pause))
       (go tfl-drop-plat-drop)
       )
      (('touch) ;; TFL note: removed 'attack so they only drop on touch
       (send-event *target* 'no-look-around (seconds 1))
       (send-event (ppointer->process (-> self parent)) 'player-stepped (-> self color))
       #f
       )
      )
    )
  :code (behavior ()
    (suspend)
    (update-transforms! (-> self root))
    (set-time! (-> self state-time))
    (logior! (-> self mask) (process-mask actor-pause))
    (loop
      (if (time-elapsed? (-> self state-time) (-> self duration))
          (go tfl-drop-plat-drop)
          )
      (suspend)
      )
    )
  :post ja-post
  )

(defbehavior tfl-drop-plat-set-fade tfl-drop-plat ()
  (let ((f0-1
          (fmin
            1.0
            (* 0.000012207031
               (- (-> self root trans y) (+ -204800.0 (-> (the-as process-drawable (-> self parent 0)) root trans y)))
               )
            )
          )
        )
    (set-vector! (-> self draw color-mult) f0-1 f0-1 f0-1 1.0)
    )
  0
  (none)
  )

(defstate tfl-drop-plat-spawn (tfl-drop-plat)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('drop)
       (go tfl-drop-plat-die)
       )
      )
    )
  :code (behavior ()
    (set! (-> self root trans y) (+ -204800.0 (-> (the-as process-drawable (-> self parent 0)) root trans y)))
    (logior! (-> self draw status) (draw-status hidden))
    (ja-post)
    (set-time! (-> self state-time))
    (loop
      (when (time-elapsed? (-> self state-time) (-> self delay))
        (let ((v1-14 (logclear (-> self draw status) (draw-status hidden)))
              (a0-5 (-> self draw))
              )
          (set! (-> a0-5 status) v1-14)
          (go tfl-drop-plat-rise a0-5)
          )
        )
      (suspend)
      )
    )
  )

(defstate tfl-drop-plat-rise (tfl-drop-plat)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('drop)
       (go tfl-drop-plat-drop)
       )
      )
    )
  :code (behavior ((arg0 draw-control))
    (set! (-> self interp) 1.0)
    (set-time! (-> self state-time))
    (set! (-> self spin-angle) 0.0)
    (set! (-> self root trans y) (+ -204800.0 (-> (the-as process-drawable (-> self parent 0)) root trans y)))
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (s5-0 #f)
          )
      (set! (-> gp-0 quad) (-> self root trans quad))
      (set! (-> gp-0 y) (-> (the-as process-drawable (-> self parent 0)) root trans y))
      (loop
        (let ((f0-6 (fmax 0.0 (- 1.0 (* 0.0033333334 (the float (- (current-time) (-> self state-time))))))))
          (set! (-> self interp) (* f0-6 f0-6))
          )
        (set! (-> self root trans y)
              (- (-> (the-as process-drawable (-> self parent 0)) root trans y) (* 204800.0 (-> self interp)))
              )
        (when (and (not s5-0) (< (-> self interp) 0.05))
          (set! s5-0 #t)
          (sound-play "bridge-piece-up" :position (the-as symbol gp-0))
          )
        (set! (-> self spin-angle) (* 10.0 (-> self spin-speed) (-> self interp)))
        (if (= (-> (the-as process-drawable (-> self parent 0)) root trans y) (-> self root trans y))
            (go tfl-drop-plat-idle)
            )
        (suspend)
        )
      )
    )
  :post (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'quaternion)))
      (quaternion-vector-angle! gp-0 (-> self spin-axis) (-> self spin-angle))
      (quaternion*! (-> self root quat) (-> (the-as process-drawable (-> self parent 0)) root quat) gp-0)
      )
    (tfl-drop-plat-set-fade)
    (transform-post)
    )
  )

(defstate tfl-drop-plat-drop (tfl-drop-plat)
  :code (behavior ()
    (when (= (-> (the-as process-drawable (-> self parent 0)) root trans y) (-> self root trans y))
      (set-time! (-> self state-time))
      (sound-play "bridge-piece-dn")
      (let ((gp-1 (the int (* (* (res-lump-float (-> self entity) 'wiggle-time :default 1.0) 300.0) (rand-vu-float-range 0.2 0.3))))) ;; tfl note: added this as a res-lump
        (while (not (time-elapsed? (-> self state-time) gp-1))
          (set! (-> self interp) (/ (the float (- (current-time) (-> self state-time))) (the float gp-1)))
          (set! (-> self spin-angle) (* 910.2222 (sin (* 196608.0 (-> self interp)))))
          (suspend)
          )
        )
      )
    (loop
      (vector-v++! (-> self root transv) (compute-acc-due-to-gravity (-> self root) (new-stack-vector0) 0.0))
      (vector-v++! (-> self root trans) (-> self root transv))
      (if (< 204800.0 (- (-> (the-as process-drawable (-> self parent 0)) root trans y) (-> self root trans y)))
          (go tfl-drop-plat-die)
          )
      (+! (-> self spin-angle) (* (-> self spin-speed) (seconds-per-frame)))
      (suspend)
      )
    )
  :post (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'quaternion)))
      (quaternion-vector-angle! gp-0 (-> self spin-axis) (-> self spin-angle))
      (quaternion*! (-> self root quat) (-> (the-as process-drawable (-> self parent 0)) root quat) gp-0)
      )
    (tfl-drop-plat-set-fade)
    (transform-post)
    )
  )

(defstate tfl-drop-plat-die (tfl-drop-plat)
  :code (behavior ()
    (cleanup-for-death self)
    )
  )

(defmethod tfl-drop-plat-method-20 ((this tfl-drop-plat))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod tfl-drop-plat-method-21 ((this tfl-drop-plat))
  (case (-> this color)
    ((1)
     (initialize-skeleton this *citb-drop-plat-red-sg* '())
     )
    ((2)
     (initialize-skeleton this *citb-drop-plat-green-sg* '())
     )
    ((3)
     (initialize-skeleton this *citb-drop-plat-blue-sg* '())
     )
    ((4)
     (initialize-skeleton this *citb-drop-plat-yellow-sg* '())
     )
    (else
      (initialize-skeleton this *citb-drop-plat-sg* '())
      )
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (let ((s3-0 (new 'stack-no-clear 'vector))
        (s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s3-0 x) (* 65536.0 (rand-vu)))
    (let ((f30-1 14563.556)
          (f0-2 (rand-vu-float-range -1.0 1.0))
          )
      (set! (-> s3-0 y) (* f30-1 (* f0-2 f0-2)))
      )
    (vector-sincos! s5-0 s4-0 s3-0)
    (set! (-> this spin-axis x) (* (-> s4-0 y) (-> s4-0 x)))
    (set! (-> this spin-axis y) (-> s5-0 y))
    (set! (-> this spin-axis z) (* (-> s4-0 y) (-> s5-0 x)))
    )
  (set! (-> this spin-axis w) 1.0)
  (set! (-> this spin-angle) 0.0)
  (set! (-> this spin-speed) (* 8192.0 (+ 1.0 (rand-vu))))
  0
  (none)
  )

(defbehavior tfl-drop-plat-init-by-other tfl-drop-plat ((arg0 vector) (arg1 time-frame) (arg2 time-frame) (arg3 int))
  (set! (-> self color) arg3)
  (set! (-> self delay) arg1)
  (set! (-> self duration) arg2)
  (tfl-drop-plat-method-20 self)
  (set! (-> self root trans quad) (-> arg0 quad))
  (vector-identity! (-> self root scale))
  (quaternion-copy! (-> self root quat) (-> (the-as process-drawable (-> self parent 0)) root quat))
  (tfl-drop-plat-method-21 self)
  (go tfl-drop-plat-spawn)
  (none)
  )

(deftype handle-inline-array (inline-array-class)
  ((data  handle  :dynamic)
   )
  )


(set! (-> handle-inline-array heap-base) (the-as uint 8))

(deftype tfl2-drop-plat (process-drawable)
  ((x-count            int32)
   (z-count            int32)
   (child-count        int32)
   (child-array        handle-inline-array)
   (child-color-array  (pointer int32)) ;; TFL note: changed from int8 to get lump to work
   (x-dir              vector  :inline)
   (z-dir              vector  :inline)
   (origin             vector  :inline)
   (x-spacing          float)
   (z-spacing          float)
   (idle-distance      float)
   (duration           time-frame)
   (drop-time          time-frame)
   )
  (:states
    tfl2-drop-plat-active
    tfl2-drop-plat-idle
    )
  )


(defmethod relocate ((this tfl2-drop-plat) (arg0 int))
  (if (nonzero? (-> this child-array))
      (&+! (-> this child-array) arg0)
      )
  (the-as tfl2-drop-plat ((method-of-type process-drawable relocate) this arg0))
  )

(defbehavior tfl2-drop-plat-spawn-children tfl2-drop-plat ()
  (local-vars (s0-0 int) (sv-48 process) (sv-64 int))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    6
    0
    (let ((s5-0 0)
          (s4-0 1)
          )
      (when (< 0.0
               (vector-dot (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> self root trans)) (-> self z-dir))
               )
        (set! s5-0 (+ (-> self z-count) -1))
        (set! s4-0 -1)
        )
      (dotimes (s3-2 (-> self z-count))
        (dotimes (s2-0 (-> self x-count))
          (let ((s1-0 (+ s2-0 (* s5-0 (-> self x-count)))))
            (set! (-> gp-0 quad) (-> self origin quad))
            (vector+*! gp-0 gp-0 (-> self x-dir) (* (-> self x-spacing) (the float s2-0)))
            (vector+*! gp-0 gp-0 (-> self z-dir) (* (-> self z-spacing) (the float s5-0)))
            (if (-> self child-color-array)
                (set! s0-0 (-> self child-color-array s1-0))
                (set! s0-0 (rand-vu-int-range 0 5))
                )
            (when (nonzero? s0-0)
              (set! sv-64 (the int (* 150.0 (rand-vu))))
              (set! sv-48 (get-process *default-dead-pool* tfl-drop-plat #x4000))
              (set! (-> self child-array data s1-0)
                    (ppointer->handle (when sv-48
                                        (let ((t9-6 (method-of-type tfl-drop-plat activate)))
                                          (t9-6 (the-as tfl-drop-plat sv-48) self 'drop-plat (the-as pointer #x70004000))
                                          )
                                        (let ((t9-7 run-function-in-process)
                                              (a0-8 sv-48)
                                              (a1-5 tfl-drop-plat-init-by-other)
                                              (a2-4 gp-0)
                                              (t0-0 (-> self duration))
                                              )
                                          ((the-as (function process function vector int int int none) t9-7)
                                           a0-8
                                           a1-5
                                           a2-4
                                           sv-64
                                           (the-as int t0-0)
                                           s0-0
                                           )
                                          )
                                        (-> sv-48 ppointer)
                                        )
                                      )
                    )
              )
            )
          )
        (let ((s2-1 (current-time)))
          (until (time-elapsed? s2-1 (seconds 0.12))
            (suspend)
            )
          )
        (+! s5-0 s4-0)
        )
      )
    )
  (set-time! (-> self drop-time))
  0
  (none)
  )

(defbehavior tfl2-drop-plat-drop-all-children tfl2-drop-plat ()
  (dotimes (gp-0 (-> self child-count))
    (send-event (handle->process (-> self child-array data gp-0)) 'drop)
    (set! (-> self child-array data gp-0) (the-as handle #f))
    )
  #f
  )

(defbehavior tfl2-drop-plat-drop-children tfl2-drop-plat ((arg0 int))
  (cond
    ((= arg0 6)
     )
    (else
      (dotimes (s5-0 (-> self child-count))
        (let ((a0-3 (handle->process (-> self child-array data s5-0))))
          (when (and a0-3 (!= (-> (the-as tfl-drop-plat a0-3) color) 6) (= arg0 (-> (the-as tfl-drop-plat a0-3) color)))
            (send-event a0-3 'drop)
            (set! (-> self child-array data s5-0) (the-as handle #f))
            )
          )
        )
      )
    )
  0
  (none)
  )

(defstate tfl2-drop-plat-idle (tfl2-drop-plat)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go tfl2-drop-plat-active)
       )
      )
    )
  :code (behavior ()
    (tfl2-drop-plat-drop-all-children)
    (loop
      (suspend)
      )
    )
  )

(defstate tfl2-drop-plat-active (tfl2-drop-plat)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('player-stepped)
       (when (time-elapsed? (-> self drop-time) (seconds (res-lump-float (-> self entity) 'stepped-time :default 0.2))) ;; tfl note: added as a res-lump
         (set-time! (-> self drop-time))
         (tfl2-drop-plat-drop-children (the-as int (-> block param 0)))
         )
       )
      (('trigger)
       (go tfl2-drop-plat-idle)
       )
      )
    )
  :code (behavior ()
    (set-time! (-> self state-time))
    (tfl2-drop-plat-spawn-children)
    (loop
      (if (or (time-elapsed? (-> self state-time) (+ (-> self duration) (seconds 2)))
              (or (not *target*)
                  (< (-> self idle-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                  )
              (not (-> self child))
              )
          (go tfl2-drop-plat-idle)
          )
      (suspend)
      )
    )
  )

(defmethod init-from-entity! ((this tfl2-drop-plat) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (let ((v1-2 (res-lump-data arg0 'count pointer)))
    (when v1-2
      (set! (-> this x-count) (-> (the-as (pointer int32) v1-2) 0))
      (set! (-> this z-count) (-> (the-as (pointer int32) v1-2) 1))
      )
    )
  (set! (-> this child-count) (* (-> this x-count) (-> this z-count)))
  (set! (-> this child-color-array) (res-lump-data arg0 'plat-type (pointer int32))) ;; TFL note: changed from int8 to get lump to work
  (when (> (-> this child-count) 0)
    (set! (-> this child-array) (new 'process 'handle-inline-array (-> this child-count)))
    (dotimes (v1-9 (-> this child-count))
      (set! (-> this child-array data v1-9) (the-as handle #f))
      )
    )
  (set! (-> this x-spacing) (res-lump-float (-> this entity) 'x-spacing :default 16384.0)) ;; TFL note: added this as a res-lump
  (set! (-> this z-spacing) (res-lump-float (-> this entity) 'z-spacing :default 16384.0)) ;; TFL note: added this as a res-lump
  (set! (-> this idle-distance) (+ (res-lump-float (-> this entity) 'idle-distance :default 40960.0) (* 0.5 (the float (-> this z-count)) (-> this z-spacing)))) ;; TFL note: added this as a res-lump
  (set! (-> this duration) (the-as time-frame (the int (* (res-lump-float (-> this entity) 'drop-time :default 5.0) 300.0)))) ;; TFL note: added this as a res-lump
  (let ((f0-7 (res-lump-float arg0 'rotoffset)))
    (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-7)
    )
  (vector-x-quaternion! (-> this x-dir) (-> this root quat))
  (vector-z-quaternion! (-> this z-dir) (-> this root quat))
  (set! (-> this origin quad) (-> this root trans quad))
  (let ((f0-10 (* -0.5 (the float (+ (-> this x-count) -1)) (-> this x-spacing)))
        (f30-0 (* -0.5 (the float (+ (-> this z-count) -1)) (-> this z-spacing)))
        )
    (vector+*! (-> this origin) (-> this origin) (-> this x-dir) f0-10)
    (vector+*! (-> this origin) (-> this origin) (-> this z-dir) f30-0)
    )
  (go tfl2-drop-plat-idle)
  (none)
  )

(deftype tfl-firehose-button (basebutton)
  ()
  )

(deftype tfl-firehose-master (process-drawable)
  ((button-id                 int32)
   (hose-id                   int32)
   (plat-mask                 uint32)
   (hose-id-dir               int32)
   (wiggled?                  symbol)
   (timeout                   time-frame)
   (last-plat-activated-time  time-frame)
   (delay-til-wiggle          time-frame)
   (ticker                    ticky  :inline)
   )
  (:states
    tfl-firehose-master-activate
    tfl-firehose-master-idle
    )
  )

(deftype tfl-firehose (process-drawable)
  ((hose-id        int32)
   (root           collide-shape :override)
   (idle-distance  float)
   (activated      int32)
   (blast-pos      vector         :inline)
   )
  (:states
    tfl-firehose-active
    tfl-firehose-blast
    tfl-firehose-idle
    )
  )

(defstate tfl-firehose-master-idle (tfl-firehose-master)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (when (= (-> proc type) tfl-firehose-button)
         (set! (-> self button-id) (-> (the-as tfl-firehose-button proc) button-id))
         (logclear! (-> self mask) (process-mask actor-pause))
         (process-entity-status! self (entity-perm-status bit-3) #t)
         (go tfl-firehose-master-activate)
         )
       )
      )
    )
  :code (behavior ()
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

(defstate tfl-firehose-master-activate (tfl-firehose-master)
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self wiggled?) #f)
    (sleep (-> self ticker) (-> self timeout))
    (set! (-> self hose-id) -1)
    (send-to-all (-> self link) 'trigger)
    (set! (-> self hose-id) 0)
    (set! (-> (the-as tfl-firehose int32) activated) 0)
    (let ((gp-0 1))
      (if (< gp-0 0)
          (set! (-> self hose-id) 32)
          )
      (set! (-> self hose-id-dir) gp-0)
      )
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (process-entity-status! self (entity-perm-status bit-3) #f)
    )
  :trans (behavior ()
    (when (completed? (-> self ticker))
      (send-to-all (-> self link) 'untrigger)
      (go tfl-firehose-master-idle)
      )
    (when (reached-delay? (-> self ticker) (-> self delay-til-wiggle))
      (when (not (-> self wiggled?))
        (set! (-> self wiggled?) #t)
        (send-to-all (-> self link) 'bounce)
        )
      )
    (when (time-elapsed? (-> self last-plat-activated-time) (seconds 0.3))
      (set-time! (-> self last-plat-activated-time))
      (let ((v1-20 (-> self hose-id))
            (a0-5 (-> self hose-id-dir))
            (a1-3 (-> self plat-mask))
            )
        (loop
          (+! v1-20 a0-5)
          (cond
            ((<= v1-20 0)
             (set! (-> self hose-id) 0)
             (return #f)
             )
            ((>= v1-20 32)
             (set! (-> self hose-id) 32)
             (return #f)
             )
            (else
              (when (logtest? a1-3 (ash 1 v1-20))
                (set! (-> self hose-id) v1-20)
                (send-to-all (-> self link) 'trigger)
                (return #f)
                )
              )
            )
          )
        )
      )
    )
  :code (behavior ()
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

(defmethod init-from-entity! ((this tfl-firehose-master) (arg0 entity-actor))
  (set! (-> this button-id) -1)
  (set! (-> this hose-id) -1)
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (set! (-> this timeout)
        (the-as time-frame (the int (* 300.0 (res-lump-float (-> this entity) 'timeout :default 10.0))))
        )
  (set! (-> this delay-til-wiggle) (+ (-> this timeout) (seconds -0.4)))
  (set! (-> this link) (new 'process 'actor-link-info this))
  (set! (-> this plat-mask) (the-as uint (get-matching-actor-type-mask (-> this link) tfl-firehose)))
  (go tfl-firehose-master-idle)
  (none)
  )


(defskelgroup *citb-firehose-sg* citb-firehose citb-firehose-lod0-jg citb-firehose-idle-ja
              ((citb-firehose-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 15)
              )

(defstate tfl-firehose-idle (tfl-firehose)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('trigger)
        (set! (-> self activated) 0)
        )
        (('untrigger)
        (set! (-> self activated) 1)
        )
      )
    )
  :code (behavior ()
    (loop
      (if (= 1 (-> self activated))
        (go tfl-firehose-active)
        )
      (suspend)
      )
    )
  :post ja-post
  )

(defstate tfl-firehose-active (tfl-firehose)
  :trans (behavior ()
    (if (= 1 (-> self activated))
      (go tfl-firehose-blast)
    )
    )
  :code (behavior ()
    (loop
      (suspend)
      )
    )
  :post ja-post
  )

(defbehavior tfl-firehose-blast-particles tfl-firehose ()
  (let ((gp-0 (new 'stack-no-clear 'quaternion)))
    (quaternion-identity! gp-0)
    (quaternion-rotate-local-x! gp-0 gp-0 -16384.0)
    (dotimes (s5-0 16)
      (quaternion-rotate-local-z! gp-0 gp-0 2048.0)
      (quaternion-copy! *particle-quat* gp-0)
      (launch-particles :system *sp-particle-system-3d* (-> *part-id-table* 3801) (-> self blast-pos))
      )
    )
  (spawn (-> self part) (-> self blast-pos))
  )

(defstate tfl-firehose-blast (tfl-firehose)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch)
       (send-event
         proc
         'attack-or-shove
         (-> block param 0)
         (static-attack-info ((mode 'burn) (shove-back (meters 6)) (shove-up (meters 3))))
         )
       )
       (('trigger)
        (set! (-> self activated) 0)
        )
        (('untrigger)
        (set! (-> self activated) 1)
        )
      )
    )
  :code (behavior ()
    (ja-no-eval :group! citb-firehose-start-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 0.75))
      )
    (ja-channel-push! 1 (seconds 0.1))
    (restore-collide-with-as (-> self root))
    (sound-play "eco-torch" :position (the-as symbol (-> self blast-pos)))
    (until (= 0 (-> self activated)) ;; TFL note: changed dotimes (gp-1 5) to condition for the button
      (ja-no-eval :group! citb-firehose-loopflame-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (set! (-> self blast-pos quad) (-> self node-list data 5 bone transform vector 3 quad))
        (tfl-firehose-blast-particles)
        (suspend)
        (ja :num! (seek! max 0.5))
        )
      )
    (clear-collide-with-as (-> self root))
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! citb-firehose-end-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 0.75))
      )
    (go tfl-firehose-idle)
    )
  :post transform-post
  )

(defmethod init-from-entity! ((this tfl-firehose) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 -61440.0 0.0 36864.0)
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> s2-0 local-sphere) 0.0 -49152.0 0.0 12288.0)
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> s2-1 local-sphere) 0.0 -61440.0 0.0 12288.0)
        (append-prim s3-0 s2-1)
        )
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> s2-2 local-sphere) 0.0 -73728.0 0.0 12288.0)
        (append-prim s3-0 s2-2)
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *citb-firehose-sg* '())
  (set! (-> this activated) 1)
  (set! (-> this idle-distance) (res-lump-float (-> this entity) 'idle-distance :default 286720.0))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1001) this))
  (clear-collide-with-as (-> this root))
  (go tfl-firehose-idle)
  (none)
  )

(deftype cavecrusher (process-drawable)
  ((root  collide-shape :override)
   )
  (:states
    cavecrusher-idle
    )
  )


(defskelgroup *cavecrusher-sg* cavecrusher cavecrusher-lod0-jg -1
              ((cavecrusher-lod0-mg (meters 20)) (cavecrusher-lod1-mg (meters 40)) (cavecrusher-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(defstate cavecrusher-idle (cavecrusher)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (when (= (-> proc type) target)
         (if ((method-of-type touching-shapes-entry prims-touching-action?)
              (the-as touching-shapes-entry (-> block param 0))
              (-> *target* control)
              (collide-action solid)
              (collide-action)
              )
             (target-attack-up *target* 'attack-or-shove 'deadlyup)
             )
         )
       )
      )
    )
  :code (behavior ()
    (loop
      (ja-no-eval :group! cavecrusher-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (update! (-> self sound))
        (suspend)
        (ja :num! (seek!))
        )
      )
    )
  :post ja-post
  )

(defmethod init-from-entity! ((this cavecrusher) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 11468.8)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *cavecrusher-sg* '())
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "crush-click" :fo-max 30) (-> this root trans))
        )
  (ja-channel-push! 1 0)
  (let ((s5-1 (-> this skel root-channel 0)))
    (joint-control-channel-group-eval!
      s5-1
      (the-as art-joint-anim (-> this draw art-group data 4))
      num-func-identity
      )
    (set! (-> s5-1 frame-num) 0.0)
    )
  (ja-post)
  (update-transforms! (-> this root))
  (go cavecrusher-idle)
  (none)
  )

(deftype caveelevator (process-drawable)
  ((root                     collide-shape-moving :override)
   (elev-mode                uint64)
   (elev-type                int32)
   (prev-frame-num           float)
   (last-update-bounce-time  time-frame)
   (orig-trans               vector                :inline)
   (sync                     sync-info             :inline)
   (smush                    smush-control         :inline)
   (anim                     int32                 2)
   (wheel-ry-mat             matrix                :inline :offset 272)
   )
  (:methods
    (caveelevator-method-20 (_type_) none)
    (caveelevator-method-21 (_type_) float)
    )
  (:states
    caveelevator-cycle-active
    caveelevator-one-way-idle-end
    caveelevator-one-way-idle-start
    caveelevator-one-way-travel-to-end
    caveelevator-one-way-travel-to-start
    )
  )


(defskelgroup *caveelevator-sg* caveelevator caveelevator-lod0-jg -1
              ((caveelevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4.25)
              )

(defmethod caveelevator-method-20 ((this caveelevator))
  (let ((v1-1 (current-time)))
    (when (!= v1-1 (-> this last-update-bounce-time))
      (set! (-> this last-update-bounce-time) v1-1)
      (when (!= (-> this smush amp) 0.0)
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (set! (-> s5-0 quad) (-> this orig-trans quad))
          (+! (-> s5-0 y) (* 819.2 (update! (-> this smush))))
          (move-to-point! (-> this root) s5-0)
          )
        )
      )
    )
  (none)
  )

(defmethod caveelevator-method-21 ((this caveelevator))
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (gp-0 (-> this draw bounds))
        )
    (vector<-cspace! s5-0 (-> this node-list data 3))
    (vector-! gp-0 s5-0 (-> this root trans))
    (set! (-> gp-0 w) 17408.0)
    )
  )

(defstate caveelevator-cycle-active (caveelevator)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (activate! (-> self smush) -1.0 60 150 1.0 1.0)
       )
      )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    )
  :code (behavior ()
    (loop
      (let ((f30-1 (* (get-current-phase (-> self sync)) (the float (ja-num-frames 0)))))
        (if (< (-> self prev-frame-num) f30-1)
            (ja :num! (seek! f30-1 10000.0))
            ;; (ja :num! (seek! f30-1 0.5))
            (ja :num-func num-func-identity :frame-num f30-1 )
            )
        (set! (-> self prev-frame-num) f30-1)
        )
      (suspend)
      )
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    )
  )

(defstate caveelevator-one-way-idle-start (caveelevator)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (activate! (-> self smush) -1.0 60 150 1.0 1.0)
       (go caveelevator-one-way-travel-to-end)
       )
      (('attack 'touch)
       (if (and (= (-> proc type) target) (>= 8192.0 (vector-vector-xz-distance (target-pos 0) (-> self root trans))))
           (go caveelevator-one-way-travel-to-end)
           )
       )
      )
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    )
  :code (behavior ()
    (ja :group! (-> (the-as art-joint-anim (+ (* (-> self anim 0) 4) (the-as int (-> self draw art-group))))
                   master-art-group-name
                   )
        :num! min
        )
    (loop
      (suspend)
      )
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    )
  )

(defstate caveelevator-one-way-travel-to-end (caveelevator)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (activate! (-> self smush) -1.0 60 150 1.0 1.0)
       )
      )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    )
  :code (behavior ()
    (ja :group! (-> self draw art-group data (-> self anim 0)) :num! min)
    (ja-no-eval :num! (seek!))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go caveelevator-one-way-idle-end)
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    )
  )

(defstate caveelevator-one-way-idle-end (caveelevator)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (activate! (-> self smush) -1.0 60 150 1.0 1.0)
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (cond
      ((zero? (-> self root riders num-riders))
       (if (time-elapsed? (-> self state-time) (seconds 3))
           (go caveelevator-one-way-travel-to-start)
           )
       )
      (else
        (set-time! (-> self state-time))
        )
      )
    (rider-trans)
    (caveelevator-method-20 self)
    )
  :code (behavior ()
    (ja :group! (-> self draw art-group data (-> self anim 0)) :num! max)
    (loop
      (suspend)
      )
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    )
  )

(defstate caveelevator-one-way-travel-to-start (caveelevator)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (activate! (-> self smush) -1.0 60 150 1.0 1.0)
       )
      )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    )
  :trans (behavior ()
    (rider-trans)
    (caveelevator-method-20 self)
    )
  :code (behavior ()
    (ja :group! (-> self draw art-group data (-> self anim 1)) :num! min)
    (ja-no-eval :num! (seek!))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go caveelevator-one-way-idle-start)
    )
  :post (behavior ()
    (rider-post)
    (caveelevator-method-21 self)
    )
  )

(defun caveelevator-joint-callback ((arg0 caveelevator))
  (let* ((gp-0 arg0)
         (f1-1 (- (-> arg0 node-list data 3 bone transform vector 3 y) (-> gp-0 orig-trans y)))
         (f30-0 (* 5.0929585 (- f1-1 (* (the float (the int (/ f1-1 12867.963))) 12867.963))))
         (s3-0 (-> arg0 node-list data 5 bone transform))
         (s4-0 (-> arg0 node-list data 4 bone transform))
         (s5-0 (new 'stack-no-clear 'vector))
         )
    (set! (-> s5-0 quad) (-> s3-0 vector 3 quad))
    (matrix-rotate-x! s3-0 f30-0)
    (matrix*! s3-0 s3-0 (-> gp-0 wheel-ry-mat))
    (set! (-> s3-0 vector 3 quad) (-> s5-0 quad))
    (set! (-> s5-0 quad) (-> s4-0 vector 3 quad))
    (matrix-rotate-x! s4-0 (- f30-0))
    (matrix*! s4-0 s4-0 (-> gp-0 wheel-ry-mat))
    (set! (-> s4-0 vector 3 quad) (-> s5-0 quad))
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this caveelevator) (arg0 entity-actor))
  (local-vars (v1-43 int) (sv-16 res-tag))
  (set! (-> this prev-frame-num) 10000.0)
  (set! (-> this last-update-bounce-time) 0)
  (logior! (-> this mask) (process-mask platform))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky rider-plat))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 17408.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *caveelevator-sg* '())
  (logior! (-> this skel status) (janim-status inited))
  (set! (-> this skel postbind-function) caveelevator-joint-callback)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-28 (res-lump-data arg0 'trans-offset (pointer float) :tag-ptr (& sv-16))))
    (when v1-28
      (+! (-> this root trans x) (-> v1-28 0))
      (+! (-> this root trans y) (-> v1-28 1))
      (+! (-> this root trans z) (-> v1-28 2))
      )
    )
  (set! (-> this orig-trans quad) (-> this root trans quad))
  (let ((f0-13 (res-lump-float (-> this entity) 'rotoffset)))
    (if (!= f0-13 0.0)
        (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-13)
        )
    )
  (let ((f0-14 (quaternion-y-angle (-> this root quat))))
    (matrix-rotate-y! (-> this wheel-ry-mat) f0-14)
    )
  (set-zero! (-> this smush))
  (let ((s5-1 (res-lump-value arg0 'mode uint32)))
    0
    (set! (-> this elev-type) (the-as int s5-1))
    (let ((v1-42 s5-1))
      (cond
        ((zero? v1-42)
         (set! v1-43 0)
         (set! (-> this anim 0) 2)
         )
        ((= (the-as uint v1-42) 1)
         (set! v1-43 1)
         (set! (-> this anim 0) 3)
         (set! (-> this anim 1) 4)
         )
        ((= (the-as uint v1-42) 2)
         (set! v1-43 0)
         (set! (-> this anim 0) 5)
         )
        (else
          (set! v1-43 0)
          (set! (-> this anim 0) 2)
          (set! (-> this elev-type) (the-as int s5-1))
          )
        )
      )
    (set! (-> this elev-mode) (the-as uint v1-43))
    (ja-channel-set! 1)
    (let ((s4-1 (-> this skel root-channel 0)))
      (joint-control-channel-group-eval!
        s4-1
        (the-as art-joint-anim (-> this draw art-group data (-> this anim 0)))
        num-func-identity
        )
      (set! (-> s4-1 frame-num) 0.0)
      )
    )
  (transform-post)
  (let ((v1-55 (-> this elev-mode)))
    (cond
      ((zero? v1-55)
       (load-params! (-> this sync) this (the-as uint 3000) 0.0 0.15 0.15)
       (go caveelevator-cycle-active)
       )
      ((= v1-55 1)
       (go caveelevator-one-way-idle-start)
       )
      )
    )
  (none)
  )

(deftype minescam (pov-camera)
  ()
  )

(defskelgroup *training-cam-sg* trainingcam trainingcam-lod0-jg -1
              ((trainingcam-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 80)
              )

(defstate pov-camera-playing (minescam)
  :virtual #t
  :code (behavior ()
    (ja-no-eval :group! trainingcam-ecoventcam-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 2.0))
      )
    (go-virtual pov-camera-done-playing)
    )
  )

(deftype mines-battlecontroller (battlecontroller)
  ()
  )

(defstate battlecontroller-play-intro-camera (mines-battlecontroller)
  :virtual #t
  :code (behavior ()
    (let ((cam (ppointer->handle
                  (process-spawn minescam :init pov-camera-init-by-other
                    (static-vectorm -419.82 115.0 1037.7) ;; TFL note: changed from (-> self root trans)
                    *training-cam-sg*
                    "ecoventcam"
                    5
                    #f
                    '()
                    :to self
                    )
                  )
            )
          )
      (while (handle->process cam)
        (suspend)
        )
      )
    (go-virtual battlecontroller-active)
    )
  )

(defstate battlecontroller-die (mines-battlecontroller)
  :virtual #t
  :code (behavior ()
    (process-entity-status! self (entity-perm-status complete) #t)
    ((-> (method-of-type battlecontroller battlecontroller-die) code))
    )
  )

(defskelgroup *citb-generator-sg* citb-generator citb-generator-lod0-jg citb-generator-idle-ja
              ((citb-generator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 4)
              )

(defskelgroup *citb-generator-broken-sg* citb-generator citb-generator-broken-lod0-jg citb-generator-idle-ja
              ((citb-generator-broken-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 4)
              )

(deftype battle-spawner (process-drawable)
  ((root             collide-shape :override)
   (normal-look      lod-set        :inline)
   (broken-look      lod-set        :inline)
   (birth-fuel-cell  symbol)
   (trigger-others   symbol)
   (part-broken      sparticle-launch-control)
   )
  (:methods
    (init! (_type_) none)
    (battle-spawner-method-21 (_type_) none)
    )
  (:states
    battle-spawner-break
    battle-spawner-broken
    battle-spawner-idle
    )
  )


(defmethod relocate ((this battle-spawner) (arg0 int))
  (if (nonzero? (-> this part-broken))
      (&+! (-> this part-broken) arg0)
      )
  (the-as battle-spawner ((method-of-type process-drawable relocate) this arg0))
  )

(defmethod deactivate ((this battle-spawner))
  (if (nonzero? (-> this part-broken))
      (kill-and-free-particles (-> this part-broken))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

(defbehavior battle-spawner-trigger-others battle-spawner ()
  (let ((gp-0 (entity-actor-count (-> self entity) 'alt-actor)))
    (dotimes (s5-0 gp-0)
      (let ((s4-0 (entity-actor-lookup (-> self entity) 'alt-actor s5-0))
            (a1-2 (new 'stack-no-clear 'event-message-block))
            )
        (set! (-> a1-2 from) self)
        (set! (-> a1-2 num-params) 0)
        (set! (-> a1-2 message) 'trigger)
        (let ((t9-2 send-event-function)
              (v1-1 s4-0)
              )
          (when (not (t9-2
                       (if v1-1
                           (-> v1-1 extra process)
                           )
                       a1-2
                       )
                     )
            (entity-birth-no-kill s4-0)
            (suspend)
            (send-event
              (if s4-0
                  (-> s4-0 extra process)
                  )
              'trigger
              )
            )
          )
        )
      )
    )
  (let ((gp-1 (current-time)))
    (while (not (time-elapsed? gp-1 (seconds 0.5)))
      (if (movie?)
          (set! gp-1 (current-time))
          )
      (suspend)
      )
    )
  (let ((gp-2 (entity-actor-count (-> self entity) 'trigger-actor)))
    (dotimes (s5-1 gp-2)
      (let ((s4-1 (entity-actor-lookup (-> self entity) 'trigger-actor s5-1))
            (a1-6 (new 'stack-no-clear 'event-message-block))
            )
        (set! (-> a1-6 from) self)
        (set! (-> a1-6 num-params) 0)
        (set! (-> a1-6 message) 'trigger)
        (let ((t9-8 send-event-function)
              (v1-19 s4-1)
              )
          (when (not (t9-8
                       (if v1-19
                           (-> v1-19 extra process)
                           )
                       a1-6
                       )
                     )
            (entity-birth-no-kill s4-1)
            (suspend)
            (send-event
              (if s4-1
                  (-> s4-1 extra process)
                  )
              'trigger
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defstate battle-spawner-idle (battle-spawner)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (when (and (>= argc 2) (= (-> block param 1) 'explode))
         (go battle-spawner-break)
         )
       )
      (('trigger)
       #t
       )
      )
    )
  :exit (behavior ()
    (stop! (-> self sound))
    )
  :code (behavior ()
    (lods-assign! (-> self draw) (-> self normal-look))
    (update-transforms! (-> self root))
    (loop
      (spawn (-> self part) (-> self root trans))
      (update! (-> self sound))
      (+! (-> *palette-fade-controls* control 3 fade) 0.3333)
      (suspend)
      )
    )
  :post ja-post
  )

(defstate battle-spawner-break (battle-spawner)
  :code (behavior ()
    (let ((gp-0 (entity-actor-count (-> self entity) 'open-actor)))
      (dotimes (s5-0 gp-0)
        (let ((s4-0 (entity-actor-lookup (-> self entity) 'open-actor s5-0))
              (a1-2 (new 'stack-no-clear 'event-message-block))
              )
          (set! (-> a1-2 from) self)
          (set! (-> a1-2 num-params) 0)
          (set! (-> a1-2 message) 'open)
          (let ((t9-2 send-event-function)
                (v1-1 s4-0)
                )
            (when (not (t9-2
                         (if v1-1
                             (-> v1-1 extra process)
                             )
                         a1-2
                         )
                       )
              (entity-birth-no-kill s4-0)
              (suspend)
              (send-event
                (if s4-0
                    (-> s4-0 extra process)
                    )
                'open
                )
              )
            )
          )
        )
      )
    (process-entity-status! self (entity-perm-status complete) #t)
    (process-spawn
      part-tracker
      :init part-tracker-init
      (-> *part-group-id-table* 1005)
      -1
      #f
      #f
      #f
      (-> self root trans)
      :to *entity-pool*
      )
    (sound-play "sagecage-open")
    (go battle-spawner-broken)
    )
  :post ja-post
  )

(defstate battle-spawner-broken (battle-spawner)
  :code (behavior ()
    (lods-assign! (-> self draw) (-> self broken-look))
    (update-transforms! (-> self root))
    (battle-spawner-trigger-others)
    (anim-loop)
    )
  :post (behavior ()
    (spawn (-> self part-broken) (-> self root trans))
    (ja-post)
    )
  )

(defmethod init! ((this battle-spawner))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-others))))
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind wall-object))
      (set! (-> s4-0 collide-with) (collide-kind target enemy))
      ;; (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s4-0 local-sphere) (meters 0.0) (meters 1.0) 0.0 (meters 5))
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod battle-spawner-method-21 ((this battle-spawner))
  (initialize-skeleton this *citb-generator-sg* '())
  (setup-lods! (-> this normal-look) *citb-generator-sg* (-> this draw art-group) (-> this entity))
  (setup-lods! (-> this broken-look) *citb-generator-broken-sg* (-> this draw art-group) (-> this entity))
  (set! (-> this link) (new 'process 'actor-link-info this))
  (set! (-> this birth-fuel-cell) (< (the-as uint 1) (the-as uint (-> this entity extra perm task))))
  (set! (-> this trigger-others) #f)
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1004) this))
  (set! (-> this part-broken) (create-launch-control (-> *part-group-id-table* 1006) this))
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "mushroom-gen" :fo-max 20) (-> this root trans))
        )
  0
  (none)
  )

(defmethod init-from-entity! ((this battle-spawner) (arg0 entity-actor))
  (init! this)
  (process-drawable-from-entity! this arg0)
  (battle-spawner-method-21 this)
  (let ((v1-4 (entity-actor-lookup (-> this entity) 'state-actor 0)))
    (if (not v1-4)
        (set! v1-4 (-> this entity))
        )
    (if (logtest? (-> v1-4 extra perm status) (entity-perm-status complete))
        (go battle-spawner-broken)
        (go battle-spawner-idle)
        )
    )
  (none)
  )

(deftype lurkerm-piston (process-drawable)
  ((root       collide-shape-moving :override)
   (sync       sync-info             :inline)
   (base       vector                :inline)
   (height     vector                :inline)
   (speed      float)
   (alt-actor  entity-actor)
   )
  (:states
    lurkerm-piston-idle
    )
  )


(defskelgroup *lurkerm-piston-sg* lurkerm-piston lurkerm-piston-geo-jg lurkerm-piston-idle-ja
              ((lurkerm-piston-geo-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 6)
              )

(defstate lurkerm-piston-idle (lurkerm-piston)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('stop)
       (process-entity-status! self (entity-perm-status complete) #t)
       (set! (-> self speed) 0.0)
       )
      )
    )
  :trans rider-trans
  :code (behavior ()
    (loop
      (ja-no-eval :group! lurkerm-piston-idle-ja :num! (seek! max (-> self speed)) :frame-num 0.0)
      (until (ja-done? 0)
        (let ((gp-0 (new-stack-vector0)))
          (set! (-> gp-0 quad) (-> self base quad))
          (+! (-> gp-0 y) (* (get-current-value-with-mirror (-> self sync) (-> self height y)) (-> self speed)))
          (move-to-point! (-> self root) gp-0)
          )
        (suspend)
        (ja :num! (seek! max (-> self speed)))
        )
      )
    )
  :post rider-post
  )

(defmethod init-from-entity! ((this lurkerm-piston) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag))
  (logior! (-> this mask) (process-mask platform))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 24576.0 0.0 0.0 20480.0)
      (set-root-prim! s4-0 s3-0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton this *lurkerm-piston-sg* '())
  (logior! (-> this skel status) (janim-status inited))
  (update-transforms! (-> this root))
  (set! (-> this base quad) (-> this root trans quad))
  (let ((f30-0 (-> this base y)))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-32 (res-lump-data arg0 'height-info pointer :tag-ptr (& sv-16))))
      (set! (-> this base y) (+ f30-0 (if (and v1-32 (> (the-as int (-> sv-16 elt-count)) 0))
                                          (-> (the-as (pointer float) v1-32))
                                          0.0
                                          )
                                )
            )
      )
    )
  (let ((s4-1 (-> this height)))
    (set! (-> s4-1 x) 0.0)
    (set! sv-32 (new 'static 'res-tag))
    (let ((v1-35 (res-lump-data arg0 'height-info (pointer float) :tag-ptr (& sv-32))))
      (set! (-> s4-1 y) (if (and v1-35 (< 1 (the-as int (-> sv-32 elt-count))))
                            (-> v1-35 1)
                            20480.0
                            )
            )
      )
    (set! (-> s4-1 z) 0.0)
    (set! (-> s4-1 w) 1.0)
    )
  (load-params! (-> this sync) this (the-as uint 1500) 0.0 0.15 0.15)
  (set! (-> this alt-actor) (entity-actor-lookup (-> this entity) 'alt-actor 0))
  (set! (-> this speed) 1.0)
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status complete)))
      (set! (-> this speed) 0.0)
      )
  (go lurkerm-piston-idle)
  (none)
  )

(defskelgroup *citb-disc-a-sg* citb-disc citb-disc-a-lod0-jg citb-disc-a-idle-ja
              ((citb-disc-a-lod0-mg (meters 20)) (citb-disc-a-lod1-mg (meters 40)) (citb-disc-a-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 12)
              :longest-edge (meters 7.5)
              )

(defskelgroup *citb-disc-b-sg* citb-disc citb-disc-b-lod0-jg citb-disc-b-idle-ja
              ((citb-disc-b-lod0-mg (meters 20)) (citb-disc-b-lod1-mg (meters 40)) (citb-disc-b-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 12)
              :longest-edge (meters 7.5)
              )

(defskelgroup *citb-disc-c-sg* citb-disc citb-disc-c-lod0-jg citb-disc-c-idle-ja
              ((citb-disc-c-lod0-mg (meters 20)) (citb-disc-c-lod1-mg (meters 40)) (citb-disc-c-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 12)
              :longest-edge (meters 11)
              )

(defskelgroup *citb-disc-d-sg* citb-disc citb-disc-d-lod0-jg citb-disc-d-idle-ja
              ((citb-disc-d-lod0-mg (meters 20)) (citb-disc-d-lod1-mg (meters 40)) (citb-disc-d-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 12)
              :longest-edge (meters 8)
              )

(deftype citb-disc (process-drawable)
  ((root       collide-shape-moving :override)
   (sync       sync-info             :inline)
   (rot-scale  float)
   )
  (:methods
    (init! (_type_) none)
    (citb-disc-method-21 (_type_) none)
    )
  (:states
    citb-disc-idle
    )
  )


(defstate citb-disc-idle (citb-disc)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch)
       (send-event proc 'no-look-around (seconds 0.25))
       #f
       )
      )
    )
  :trans rider-trans
  :code (behavior ()
    (loop
      (update! (-> self sound))
      (quaternion-axis-angle!
        (-> self root quat)
        0.0
        1.0
        0.0
        (* 65536.0 (get-current-phase (-> self sync)) (-> self rot-scale))
        )
      (suspend)
      )
    )
  :post rider-post
  )

(defmethod init! ((this citb-disc))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) default-collision-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (alloc-riders s5-0 1)
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid rider-plat-sticky rider-plat))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 49152.0)
      (set-root-prim! s5-0 s4-0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod citb-disc-method-21 ((this citb-disc))
  0
  (none)
  )

(defmethod init-from-entity! ((this citb-disc) (arg0 entity-actor))
  (init! this)
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (load-params! (-> this sync) this (the-as uint 3000) 0.0 0.15 0.15)
  (cond
    ((> (-> this sync period) 0)
     (set! (-> this rot-scale) 1.0)
     )
    (else
      (set! (-> this rot-scale) -1.0)
      (let ((v1-8 (abs (the-as int (-> this sync period)))))
        (set! (-> this sync period) (the-as uint v1-8))
        )
      )
    )
  (citb-disc-method-21 this)
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "rotate-plat" :fo-max 20) (-> this root trans))
        )
  (logior! (-> this skel status) (janim-status inited))
  (go citb-disc-idle)
  (none)
  )

(deftype citb-disc-a (citb-disc)
  ()
  )


(deftype citb-disc-b (citb-disc)
  ()
  )


(deftype citb-disc-c (citb-disc)
  ()
  )


(deftype citb-disc-d (citb-disc)
  ()
  )


(defmethod citb-disc-method-21 ((this citb-disc-a))
  (initialize-skeleton this *citb-disc-a-sg* '())
  0
  (none)
  )

(defmethod citb-disc-method-21 ((this citb-disc-b))
  (initialize-skeleton this *citb-disc-b-sg* '())
  0
  (none)
  )

(defmethod citb-disc-method-21 ((this citb-disc-c))
  (initialize-skeleton this *citb-disc-c-sg* '())
  0
  (none)
  )

(defmethod citb-disc-method-21 ((this citb-disc-d))
  (initialize-skeleton this *citb-disc-d-sg* '())
  0
  (none)
  )

(defskelgroup *citb-hose-sg* citb-hose citb-hose-lod0-jg citb-hose-idle-ja
              ((citb-hose-lod0-mg (meters 20)) (citb-hose-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              )

(deftype mines-hose (process-drawable)
  ()
  (:states
    mines-hose-die
    mines-hose-idle
    mines-hose-spawn
    )
  )


(defbehavior mines-hose-event-handler mines-hose ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('spawn)
     (go mines-hose-spawn)
     )
    (('trigger)
     (go mines-hose-die)
     )
    )
  )

(defstate mines-hose-idle (mines-hose)
  :event mines-hose-event-handler
  :code (behavior ()
    (loop
      (ja-no-eval :group! citb-hose-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    )
  :post ja-post
  )

(defstate mines-hose-spawn (mines-hose)
  :event mines-hose-event-handler
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! citb-hose-spit-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go mines-hose-idle)
    )
  :post ja-post
  )

(defstate mines-hose-die (mines-hose)
  :event mines-hose-event-handler
  :code (behavior ()
    (process-entity-status! self (entity-perm-status complete) #t)
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! citb-hose-die-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (anim-loop)
    )
  :post ja-post
  )

(defmethod init-from-entity! ((this mines-hose) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *citb-hose-sg* '())
  (let ((v1-3 (entity-actor-lookup (-> this entity) 'state-actor 0)))
    (if (not v1-3)
        (set! v1-3 (-> this entity))
        )
    (if (logtest? (-> v1-3 extra perm status) (entity-perm-status complete))
        (go mines-hose-die)
        (go mines-hose-idle)
        )
    )
  (none)
  )

(deftype minesflamepots (process-drawable)
  ((root                collide-shape :override)
   (shove-up            float)
   (cycle-speed         int32)
   (cycle-pause         int32)
   (cycle-offset        uint32)
   (was-deadly?         symbol)
   (should-play-sound?  symbol)
   (launch-pos          vector         2 :inline)
   )
  (:states
    minesflamepots-active
    )
  )

(defstate minesflamepots-active (minesflamepots)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch 'attack)
       (when (= (-> proc type) target)
         (when ((method-of-type touching-shapes-entry prims-touching-action?)
                (the touching-shapes-entry (-> event param 0))
                (-> *target* control)
                (collide-action solid)
                (collide-action)
                )
           (let ((s4-0 (new 'stack 'attack-info)))
             (calc-shove-up (-> self root) s4-0 (-> self shove-up))
             (if (or (= (-> *target* control unknown-surface00 mode) 'air)
                     (>= (+ (-> *display* base-frame-counter) (seconds -0.2)) (-> *target* control unknown-dword11))
                     (< 0.75 (-> *target* control poly-normal y))
                     )
                 (send-event
                   proc
                   'attack-or-shove
                   (-> event param 0)
                   (static-attack-info ((mode 'burn) (vector (-> s4-0 vector)) (shove-up (-> s4-0 shove-up))))
                   )
                 (send-event
                   proc
                   'attack-or-shove
                   (-> event param 0)
                   (static-attack-info ((mode 'burn)
                                        (shove-up (meters 0))
                                        (shove-back (meters 2))
                                        (vector (-> *target* control poly-normal))
                                        (angle 'shove)
                                        )
                                       )
                   )
                 )
             )
           )
         )
       )
      )
    )
  :trans (behavior ()
    (let* ((v1-0 (-> self cycle-speed))
           (a0-1 (- v1-0 (-> self cycle-pause)))
           (gp-0 (mod (+ (-> *display* base-frame-counter) (the time-frame (-> self cycle-offset))) v1-0))
           )
      (cond
        ((< gp-0 a0-1)
         (when (sphere-in-view-frustum? (the sphere (-> self root root-prim prim-core)))
           (launch-particles (-> *part-id-table* 3817) (the vector (-> self launch-pos)))
           )
         (when (-> self should-play-sound?)
           (set! (-> self should-play-sound?) #f)
           (sound-play "hot-flame")
           )
         (cond
           ((< gp-0 30)
            (when (-> self was-deadly?)
              (set! (-> self was-deadly?) #f)
              (clear-collide-with-as (-> self root))
              )
            )
           (else
             (when (not (-> self was-deadly?))
               (set! (-> self was-deadly?) #t)
               (restore-collide-with-as (-> self root))
               )
             )
           )
         (when (and (not (-> self was-deadly?)) (< 60 gp-0))
           (set! (-> self was-deadly?) #t)
           (restore-collide-with-as (-> self root))
           )
         )
        (else
          (set! (-> self should-play-sound?) #t)
          (when (-> self was-deadly?)
            (set! (-> self was-deadly?) #f)
            (clear-collide-with-as (-> self root))
            )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    (none)
    )
  )

(defmethod init-from-entity! ((this minesflamepots) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> this was-deadly?) #f)
  (set! (-> this should-play-sound?) #f)
  (set! (-> this shove-up) (res-lump-float arg0 'shove :default (meters 5.0)))
  (logclear! (-> this mask) (process-mask enemy))
  (logclear! (-> this mask) (process-mask attackable))
  (logior! (-> this mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the uint 4) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) 0.0 (meters 7) 0.0 (meters 5))
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-0 local-sphere) 0.0 (meters 3) 0.0 (meters 2))
        (append-prim s3-0 s2-0)
        )
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the uint 1))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core offense) (collide-offense no-offense))
        (set-vector! (-> s2-1 local-sphere) 0.0 (meters 6) 0.0 (meters 2))
        (append-prim s3-0 s2-1)
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (let ((v1-42 (new 'process 'path-control this 'path 0.0)))
    (set! (-> this path) v1-42)
    (logior! (-> v1-42 flags) (path-control-flag display draw-line draw-point draw-text))
    (if (<= (-> v1-42 curve num-cverts) 0)
        (go process-drawable-art-error "no path")
        )
    )
  (let ((f0-23 (res-lump-float arg0 'rotoffset)))
    (if (!= f0-23 0.0)
        (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-23)
        )
    )
  (let ((f30-0 (quaternion-y-angle (-> this root quat))))
    (let ((s4-1 (-> this launch-pos)))
      (let ((v1-53 s4-1))
        (set! (-> v1-53 0 x) 0.0)
        (set! (-> v1-53 0 y) 0.0)
        (set! (-> v1-53 0 z) 0.0)
        (set! (-> v1-53 0 w) 1.0)
        )
      (vector-rotate-around-y! (the vector s4-1) (the vector s4-1) f30-0)
      (vector+! (the vector s4-1) (the vector s4-1) (-> this root trans))
      )
    (let ((s4-2 (the object (&-> this stack 112))))
      (set-vector! (the vector s4-2) -6144.0 0.0 0.0 1.0)
      (vector-rotate-around-y! (the vector s4-2) (the vector s4-2) f30-0)
      (vector+! (the vector s4-2) (the vector s4-2) (-> this root trans))
      )
    (let ((s4-3 (-> this root root-prim)))
      (dotimes (s3-1 (-> (the collide-shape-prim-group s4-3) num-prims))
        (let ((a1-19 (-> (the collide-shape-prim-group s4-3) prims s3-1 local-sphere)))
          (vector-rotate-around-y! a1-19 a1-19 f30-0)
          )
        )
      )
    )
  (update-transforms! (-> this root))
  (let ((f30-1 300.0))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-70 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-16))))
      (set! (-> this cycle-speed) (the int (* f30-1 (if (and v1-70 (> (the int (-> sv-16 elt-count)) 0))
                                                       (-> v1-70 0)
                                                       4.0
                                                       )
                                             )
                                      )
            )
      )
    )
  (let ((f30-2 (the float (-> this cycle-speed))))
    (set! sv-32 (new 'static 'res-tag))
    (let ((v1-74 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-32))))
      (set! (-> this cycle-offset)
            (the uint (the int (* f30-2 (if (and v1-74 (< 1 (the int (-> sv-32 elt-count))))
                                               (-> v1-74 1)
                                               0.0
                                               )
                                     )
                              )
                    )
            )
      )
    )
  (let ((f30-3 300.0))
    (set! sv-48 (new 'static 'res-tag))
    (let ((v1-77 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-48))))
      (set! (-> this cycle-pause) (the int (* f30-3 (if (and v1-77 (< 2 (the int (-> sv-48 elt-count))))
                                                       (-> v1-77 2)
                                                       2.0
                                                       )
                                             )
                                      )
            )
      )
    )
  (go minesflamepots-active)
  (none)
  )